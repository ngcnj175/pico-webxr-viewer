debugBtn.onclick = function() {
        console.log('Debug toggle clicked');
        toggleDebugDisplay();
      };<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>PICO4 WebXR 3D Viewer (Fixed VR)</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0d10;color:#e8eef8;font-family:Arial, sans-serif}
    #ui{position:fixed;left:10px;right:10px;top:10px;background:rgba(0,0,0,0.9);padding:15px;border-radius:8px;z-index:100}
    #controls{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:10px}
    #url{flex:1;min-width:200px;padding:8px;border:1px solid #444;background:#222;color:#fff;border-radius:4px}
    button{padding:8px 12px;border:1px solid #444;background:#333;color:#fff;border-radius:4px;cursor:pointer}
    button:hover{background:#555}
    button:disabled{background:#111;color:#666;cursor:not-allowed}
    #vrButton{position:fixed!important;bottom:20px!important;right:20px!important;padding:15px 25px!important;background:#1976d2!important;color:white!important;border:none!important;border-radius:8px!important;font-size:16px!important;font-weight:bold!important;cursor:pointer!important;z-index:200!important}
    #vrButton:hover{background:#1565c0!important}
    #status{background:#111;padding:8px;border-radius:4px;font-size:12px;margin-top:10px;border-left:4px solid #666}
    .error{border-left-color:#ff4444}
    .success{border-left-color:#44ff44}
    .warning{border-left-color:#ffff44}
    #fileInput{display:none}
    #dropZone{position:fixed;inset:0;border:3px dashed #44f;display:none;place-content:center;background:rgba(0,100,255,0.1);z-index:50;font-size:24px;color:#44f}
    #corsHelp{background:rgba(255,193,7,0.1);border:1px solid #ffc107;border-radius:4px;padding:8px;margin:5px 0;font-size:11px}
  </style>
</head>
<body>
  <div id="ui">
    <div id="controls">
      <input id="url" placeholder="3D Model URL (.obj/.glb/.stl)" value="">
      <button id="pasteBtn">貼り付け</button>
      <button id="loadBtn">読み込む</button>
      <button id="fileBtn">ファイル選択</button>
      <button id="resetBtn">リセット</button>
      <button id="debugBtn">デバッグ表示</button>
    </div>
    <div id="controls">
      <button id="rotateL">⟲ 左回転</button>
      <button id="rotateR">⟳ 右回転</button>
      <button id="rotateUp">↑ 上回転</button>
      <button id="rotateDown">↓ 下回転</button>
      <button id="scaleUp">拡大 +</button>
      <button id="scaleDown">縮小 -</button>
    </div>
    <div id="corsHelp">
      🎮 <strong>VR操作方法 (PICO4):</strong><br>
      • <strong>左スティック:</strong> 視点移動 (上下=Y軸移動、左右=X軸移動)<br>
      • <strong>右スティック:</strong> オブジェクト回転 (上下=X軸回転、左右=Y軸回転)<br>
      • <strong>Yボタン:</strong> 視点前進 | <strong>Xボタン:</strong> 視点後退<br>
      • <strong>Aボタン:</strong> オブジェクト縮小 | <strong>Bボタン:</strong> オブジェクト拡大<br>
      📁 <strong>読み込み:</strong> 「読み込む」ボタンで自動的にCORS制限回避
    </div>
    <div id="status">準備完了 - URLまたはファイルを選択してください</div>
  </div>

  <!-- デバッグ情報表示エリア -->
  <div id="debugInfo" style="position:fixed;top:200px;right:10px;width:300px;background:rgba(0,0,0,0.8);color:#fff;padding:10px;border-radius:5px;font-family:monospace;font-size:11px;display:none;z-index:150;max-height:400px;overflow-y:auto;">
    <div style="font-weight:bold;margin-bottom:5px;">VRコントローラーデバッグ</div>
    <div id="debugOutput"></div>
  </div>

  <input type="file" id="fileInput" accept=".obj,.glb,.gltf,.stl">
  <div id="dropZone">ファイルをドロップしてください</div>

  <script>
    console.log('PICO4 WebXR Viewer - Script starting...');
    
    // グローバル変数
    let scene, camera, renderer, controls, currentModel;
    let isLoading = false;
    let vrSession = null;
    
    // UI要素を取得
    const statusEl = document.getElementById('status');
    const urlInput = document.getElementById('url');
    const loadBtn = document.getElementById('loadBtn');
    const pasteBtn = document.getElementById('pasteBtn');
    const fileBtn = document.getElementById('fileBtn');
    const resetBtn = document.getElementById('resetBtn');
    const debugBtn = document.getElementById('debugBtn');
    const fileInput = document.getElementById('fileInput');
    const dropZone = document.getElementById('dropZone');
    const rotateL = document.getElementById('rotateL');
    const rotateR = document.getElementById('rotateR');
    const rotateUp = document.getElementById('rotateUp');
    const rotateDown = document.getElementById('rotateDown');
    const scaleUp = document.getElementById('scaleUp');
    const scaleDown = document.getElementById('scaleDown');
    const debugInfo = document.getElementById('debugInfo');
    const debugOutput = document.getElementById('debugOutput');

    // ステータス更新関数
    function updateStatus(message, type) {
      console.log('Status:', message, type);
      statusEl.textContent = message;
      statusEl.className = type || '';
    }

    // ローディング状態管理
    function setLoading(loading) {
      isLoading = loading;
      loadBtn.disabled = loading;
      pasteBtn.disabled = loading;
      if (loading) {
        updateStatus('読み込み中...', 'warning');
      }
    }

    // デバッグ表示用の関数
    let debugVisible = false;
    let debugMessages = [];

    function addDebugMessage(message) {
      const timestamp = new Date().toLocaleTimeString();
      debugMessages.push(`[${timestamp}] ${message}`);
      if (debugMessages.length > 20) {
        debugMessages.shift(); // 古いメッセージを削除
      }
      if (debugVisible && debugOutput) {
        debugOutput.innerHTML = debugMessages.join('<br>');
        debugOutput.scrollTop = debugOutput.scrollHeight;
      }
      console.log(message); // コンソールにも出力
    }

    function toggleDebugDisplay() {
      debugVisible = !debugVisible;
      if (debugInfo) {
        debugInfo.style.display = debugVisible ? 'block' : 'none';
        debugBtn.textContent = debugVisible ? 'デバッグ非表示' : 'デバッグ表示';
        if (debugVisible && debugOutput) {
          debugOutput.innerHTML = debugMessages.join('<br>');
        }
      }
    }

    // ファイル形式の自動判別
    function detectFileFormat(url, filename) {
      const name = (filename || url || '').toLowerCase();
      if (name.includes('.obj')) return 'obj';
      if (name.includes('.glb') || name.includes('.gltf')) return 'glb';
      if (name.includes('.stl')) return 'stl';
      return 'obj'; // デフォルト
    }

    // より確実なDropbox URL変換
    function fixDropboxURL(url) {
      if (!url || !url.includes('dropbox.com')) return url;
      
      console.log('Original Dropbox URL:', url);
      
      // Dropboxの新しい共有リンク形式を直接ダウンロードリンクに変換
      if (url.includes('/scl/fi/')) {
        // パラメータを全て削除して raw=1 のみにする
        const baseUrl = url.split('?')[0];
        const params = new URLSearchParams(url.split('?')[1] || '');
        const rlkey = params.get('rlkey');
        
        if (rlkey) {
          const newUrl = `${baseUrl}?rlkey=${rlkey}&raw=1`;
          console.log('Fixed Dropbox URL:', newUrl);
          return newUrl;
        }
      }
      
      // 従来の形式
      const baseUrl = url.split('?')[0];
      const newUrl = baseUrl + '?raw=1';
      console.log('Fixed traditional Dropbox URL:', newUrl);
      return newUrl;
    }

    // Three.jsの初期化
    function initThreeJS() {
      try {
        console.log('Loading Three.js...');
        updateStatus('3Dエンジンを初期化中...', 'warning');
        
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
        script.onload = function() {
          console.log('Three.js loaded successfully');
          setupScene();
        };
        script.onerror = function() {
          updateStatus('Three.js読み込みエラー - ネットワーク接続を確認してください', 'error');
        };
        document.head.appendChild(script);
        
      } catch (error) {
        console.error('Init error:', error);
        updateStatus('初期化エラー: ' + error.message, 'error');
      }
    }

    // シーン設定
    function setupScene() {
      try {
        console.log('Setting up 3D scene...');
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0b0d10);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 8); // デスクトップ用初期位置

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true; // WebXR有効化
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        // VRボタンの作成と設定
        createVRButton();

        // ライト設定
        const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(10, 10, 5);
        scene.add(directionalLight);

        // 床のグリッド
        const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
        scene.add(gridHelper);

        // マウス・タッチ操作の設定
        setupControls();

        // アニメーションループ開始
        renderer.setAnimationLoop(animate);

        updateStatus('3Dエンジン初期化完了 - VRボタンをチェックしてください', 'success');
        
      } catch (error) {
        console.error('Scene setup error:', error);
        updateStatus('シーン設定エラー: ' + error.message, 'error');
      }
    }

    // VRボタンの作成（PICO4対応）
    function createVRButton() {
      console.log('Creating VR button...');
      
      const vrButton = document.createElement('button');
      vrButton.id = 'vrButton';
      vrButton.textContent = 'Enter VR';
      document.body.appendChild(vrButton);

      // WebXR対応チェック
      if ('xr' in navigator) {
        console.log('WebXR API found');
        
        navigator.xr.isSessionSupported('immersive-vr')
          .then(function(supported) {
            console.log('VR supported:', supported);
            if (supported) {
              vrButton.style.display = 'block';
              updateStatus('VRデバイス対応確認済み - Enter VRボタンが利用可能です', 'success');
              
              vrButton.onclick = function() {
                console.log('VR button clicked');
                toggleVR();
              };
            } else {
              vrButton.style.display = 'none';
              updateStatus('VRデバイスが検出されていません', 'warning');
            }
          })
          .catch(function(error) {
            console.error('VR support check failed:', error);
            vrButton.style.display = 'none';
            updateStatus('VR対応チェックエラー: ' + error.message, 'error');
          });
      } else {
        console.log('WebXR API not found');
        vrButton.style.display = 'none';
        updateStatus('WebXR非対応ブラウザです', 'warning');
      }
    }

    // VRセッションの開始時にカメラ位置を調整
    async function toggleVR() {
      try {
        console.log('Toggling VR mode...');
        
        if (vrSession) {
          console.log('Ending VR session');
          await vrSession.end();
        } else {
          console.log('Starting VR session');
          updateStatus('VRセッションを開始中...', 'warning');
          
          vrSession = await navigator.xr.requestSession('immersive-vr', {
            optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking']
          });
          
          console.log('VR session started');
          
          vrSession.addEventListener('end', function() {
            console.log('VR session ended');
            vrSession = null;
            document.getElementById('vrButton').textContent = 'Enter VR';
            updateStatus('VRモードを終了しました', 'success');
          });

          await renderer.xr.setSession(vrSession);
          
          // VRモード開始時にカメラ位置を調整
          if (currentModel) {
            const box = new THREE.Box3().setFromObject(currentModel);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            
            // VR用視点: オブジェクト全体が見えるように手前に配置（Y軸は同じ高さ）
            camera.position.set(0, 0, maxDim * 3); // 手前（Z軸+方向）に配置
            console.log(`VR camera position set to: x=0, y=0, z=${maxDim * 3}`);
          }
          
          document.getElementById('vrButton').textContent = 'Exit VR';
          updateStatus('VRモード開始 - 新しい操作方法でコントロールしてください', 'success');
        }
      } catch (error) {
        console.error('VR toggle error:', error);
        let message = 'VRモードエラー: ';
        if (error.message.includes('denied')) {
          message += 'VR権限が拒否されました。ブラウザ設定を確認してください。';
        } else if (error.message.includes('not found')) {
          message += 'VRデバイスが見つかりません。PICO4が正しく接続されているか確認してください。';
        } else {
          message += error.message;
        }
        updateStatus(message, 'error');
      }
    }

    // アニメーション関数
    function animate() {
      handleVRControls();
      renderer.render(scene, camera);
    }

    // VRコントローラー操作（画面デバッグ対応版）
    function handleVRControls() {
      if (!renderer.xr.isPresenting) return;
      
      const session = renderer.xr.getSession();
      if (!session) return;

      // 操作設定
      const DEADZONE = 0.1;
      const VIEW_SPEED = 0.08;
      const ROTATION_SPEED = 0.04;
      const SCALE_FACTOR = 0.02;

      // 全入力ソースをデバッグ出力
      if (session.inputSources.length === 0) {
        addDebugMessage('⚠️ コントローラーが検出されません');
        return;
      }

      // コントローラーを配列に格納
      const controllers = Array.from(session.inputSources);
      addDebugMessage(`🎮 コントローラー数: ${controllers.length}`);

      for (let i = 0; i < controllers.length; i++) {
        const inputSource = controllers[i];
        const gamepad = inputSource.gamepad;
        const handedness = inputSource.handedness || `controller_${i}`;
        
        if (!gamepad) {
          addDebugMessage(`Controller ${i} (${handedness}): ゲームパッドなし`);
          continue;
        }

        // アクティブな入力のみ詳細表示
        const activeButtons = gamepad.buttons.map((btn, idx) => btn.pressed ? idx : null).filter(x => x !== null);
        const activeAxes = gamepad.axes.map((axis, idx) => Math.abs(axis) > DEADZONE ? `${idx}:${axis.toFixed(2)}` : null).filter(x => x !== null);
        
        if (activeButtons.length > 0 || activeAxes.length > 0) {
          addDebugMessage(`Controller ${i} (${handedness}): ボタン[${activeButtons.join(',')}] 軸[${activeAxes.join(',')}]`);
        }

        // 第1コントローラー（通常左手）: 視点操作
        if (i === 0) {
          // スティック操作
          if (gamepad.axes.length >= 2) {
            const xAxis = gamepad.axes[0];
            const yAxis = gamepad.axes[1];
            
            if (Math.abs(xAxis) > DEADZONE) {
              camera.position.x += xAxis * VIEW_SPEED;
              addDebugMessage(`👀 カメラX移動: ${xAxis.toFixed(2)} → ${camera.position.x.toFixed(2)}`);
            }
            
            if (Math.abs(yAxis) > DEADZONE) {
              camera.position.y += -yAxis * VIEW_SPEED;
              addDebugMessage(`👀 カメラY移動: ${(-yAxis).toFixed(2)} → ${camera.position.y.toFixed(2)}`);
            }
          }
          
          // ボタン操作
          for (let btnIdx = 0; btnIdx < gamepad.buttons.length; btnIdx++) {
            if (gamepad.buttons[btnIdx].pressed) {
              if (btnIdx === 0) {
                camera.position.z += VIEW_SPEED;
                addDebugMessage(`🔙 ボタン${btnIdx}: カメラ後退 → Z:${camera.position.z.toFixed(2)}`);
              } else if (btnIdx === 1) {
                camera.position.z -= VIEW_SPEED;
                addDebugMessage(`🔜 ボタン${btnIdx}: カメラ前進 → Z:${camera.position.z.toFixed(2)}`);
              } else if (btnIdx === 2) {
                camera.position.z += VIEW_SPEED;
                addDebugMessage(`🔙 Xボタン(${btnIdx}): カメラ後退 → Z:${camera.position.z.toFixed(2)}`);
              } else if (btnIdx === 3) {
                camera.position.z -= VIEW_SPEED;
                addDebugMessage(`🔜 Yボタン(${btnIdx}): カメラ前進 → Z:${camera.position.z.toFixed(2)}`);
              } else {
                addDebugMessage(`❓ 左手ボタン${btnIdx}が押されました`);
              }
            }
          }
        }
        
        // 第2コントローラー（通常右手）: オブジェクト操作
        else if (i === 1 && currentModel) {
          // スティック操作
          let xAxis, yAxis;
          
          if (gamepad.axes.length >= 4) {
            xAxis = gamepad.axes[2];
            yAxis = gamepad.axes[3];
          } else if (gamepad.axes.length >= 2) {
            xAxis = gamepad.axes[0];
            yAxis = gamepad.axes[1];
          }
          
          if (xAxis !== undefined && yAxis !== undefined) {
            if (Math.abs(xAxis) > DEADZONE) {
              currentModel.rotation.y -= xAxis * ROTATION_SPEED;
              addDebugMessage(`🔄 オブジェクトY回転: ${(-xAxis).toFixed(2)} → ${currentModel.rotation.y.toFixed(2)}`);
            }
            
            if (Math.abs(yAxis) > DEADZONE) {
              currentModel.rotation.x += yAxis * ROTATION_SPEED;
              addDebugMessage(`🔄 オブジェクトX回転: ${yAxis.toFixed(2)} → ${currentModel.rotation.x.toFixed(2)}`);
            }
          }
          
          // ボタン操作
          for (let btnIdx = 0; btnIdx < gamepad.buttons.length; btnIdx++) {
            if (gamepad.buttons[btnIdx].pressed) {
              if (btnIdx === 0) {
                currentModel.scale.multiplyScalar(1 - SCALE_FACTOR);
                currentModel.scale.clampScalar(0.05, 20.0);
                addDebugMessage(`🔻 Aボタン(${btnIdx}): 縮小 → ${currentModel.scale.x.toFixed(3)}`);
              } else if (btnIdx === 1) {
                currentModel.scale.multiplyScalar(1 + SCALE_FACTOR);
                currentModel.scale.clampScalar(0.05, 20.0);
                addDebugMessage(`🔺 Bボタン(${btnIdx}): 拡大 → ${currentModel.scale.x.toFixed(3)}`);
              } else {
                addDebugMessage(`❓ 右手ボタン${btnIdx}が押されました`);
              }
            }
          }
        }
      }
    }

    // マウス・タッチコントロール
    function setupControls() {
      let isMouseDown = false;
      let mouseX = 0, mouseY = 0;

      const canvas = renderer.domElement;

      canvas.addEventListener('mousedown', function(e) {
        isMouseDown = true;
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      canvas.addEventListener('mouseup', function() {
        isMouseDown = false;
      });

      canvas.addEventListener('mousemove', function(e) {
        if (!isMouseDown || !currentModel) return;
        
        const deltaX = e.clientX - mouseX;
        const deltaY = e.clientY - mouseY;
        
        currentModel.rotation.y += deltaX * 0.01;
        currentModel.rotation.x += deltaY * 0.01;
        
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      canvas.addEventListener('wheel', function(e) {
        e.preventDefault();
        if (currentModel) {
          const scale = e.deltaY > 0 ? 0.9 : 1.1;
          currentModel.scale.multiplyScalar(scale);
        } else {
          camera.position.z += e.deltaY * 0.01;
          camera.position.z = Math.max(1, Math.min(50, camera.position.z));
        }
      });
    }

    // 複数のCORSプロキシサービス
    const CORS_PROXIES = [
      'https://api.allorigins.win/raw?url=',
      'https://corsproxy.io/?',
      'https://cors-anywhere.herokuapp.com/'
    ];

    // より堅牢なモデル読み込み（CORS回避対応）
    async function loadModel(url, useProxy = false) {
      if (isLoading || !url.trim()) {
        if (!url.trim()) updateStatus('URLが入力されていません', 'warning');
        return;
      }
      
      setLoading(true);
      
      try {
        // モデルクリア
        if (currentModel) {
          scene.remove(currentModel);
          currentModel = null;
        }

        // ファイル形式自動判別
        const format = detectFileFormat(url);
        updateStatus(`${format.toUpperCase()}ファイルとして読み込み中...`, 'warning');

        // URL修正
        let targetUrl = fixDropboxURL(url);
        console.log('Target URL:', targetUrl);

        let data;
        let success = false;

        if (useProxy) {
          // プロキシ経由で読み込み
          updateStatus('CORS制限回避のため、プロキシサービスを使用中...', 'warning');
          
          for (let i = 0; i < CORS_PROXIES.length && !success; i++) {
            const proxyUrl = CORS_PROXIES[i] + encodeURIComponent(targetUrl);
            console.log(`Trying proxy ${i + 1}/${CORS_PROXIES.length}:`, proxyUrl);
            
            try {
              const response = await fetch(proxyUrl, {
                method: 'GET',
                headers: {
                  'Accept': 'text/plain, application/octet-stream, */*'
                }
              });
              
              if (response.ok) {
                data = await response.text();
                console.log(`Proxy ${i + 1} successful, data length:`, data.length);
                success = true;
                updateStatus(`プロキシ経由で読み込み成功 (${format.toUpperCase()})`, 'success');
                break;
              } else {
                console.log(`Proxy ${i + 1} failed:`, response.status, response.statusText);
              }
            } catch (proxyError) {
              console.log(`Proxy ${i + 1} error:`, proxyError.message);
            }
          }
          
          if (!success) {
            throw new Error('全てのプロキシサービスで読み込みに失敗しました。ローカルファイルを使用してください。');
          }
          
        } else {
          // 直接読み込み
          console.log('Trying direct access...');
          
          // 複数のアプローチを試行
          const attempts = [
            { url: targetUrl, mode: 'cors' },
            { url: targetUrl, mode: 'no-cors' }, // no-corsモードも試行
            { url: targetUrl.replace('&raw=1', '&dl=1'), mode: 'cors' }, // 代替パラメータ
          ];

          for (const attempt of attempts) {
            try {
              console.log(`Trying direct access: ${attempt.url} (mode: ${attempt.mode})`);
              
              const response = await fetch(attempt.url, {
                method: 'GET',
                mode: attempt.mode,
                cache: 'no-cache',
                headers: {
                  'Accept': 'text/plain, application/octet-stream, */*',
                  'User-Agent': 'Mozilla/5.0 (compatible; 3DViewer/1.0)'
                }
              });
              
              if (response.ok) {
                data = await response.text();
                if (data && data.length > 0) {
                  console.log('Direct access successful, data length:', data.length);
                  success = true;
                  break;
                }
              }
            } catch (directError) {
              console.log('Direct access attempt failed:', directError.message);
            }
          }
          
          if (!success) {
            throw new Error('CORS制限によりファイルにアクセスできません。「プロキシ経由」ボタンを試すか、ローカルファイルを使用してください。');
          }
        }

        if (!data || data.length === 0) {
          throw new Error('ファイルデータが取得できませんでした');
        }

        console.log(`Data loaded successfully, length: ${data.length}, format: ${format}`);

        // フォーマット別パース
        if (format === 'obj') {
          currentModel = parseOBJ(data);
        } else if (format === 'stl') {
          currentModel = parseSTL(data);
        } else {
          throw new Error('GLBファイルは現在非対応です。OBJまたはSTLファイルを使用してください。');
        }

        if (currentModel) {
          scene.add(currentModel);
          
          // モデルを中央に配置
          const box = new THREE.Box3().setFromObject(currentModel);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());
          
          currentModel.position.sub(center);
          
          // カメラ位置を調整（VR対応）
          const maxDim = Math.max(size.x, size.y, size.z);
          // VRモード用に距離を大きく取る
          const vrDistance = maxDim * 4; // 通常の2倍の距離
          camera.position.set(0, 1.6, vrDistance); // VR用の高さと距離
          
          updateStatus(`モデル読み込み完了！ (${format.toUpperCase()}, サイズ: ${maxDim.toFixed(2)}, VR距離: ${vrDistance.toFixed(2)})`, 'success');
        }

      } catch (error) {
        console.error('Load error:', error);
        let errorMessage = error.message || '不明なエラー';
        
        // エラーメッセージを詳細化
        if (errorMessage.includes('Failed to fetch')) {
          errorMessage = 'ネットワークエラー (CORS制限の可能性)。「プロキシ経由」ボタンを試してください。';
        } else if (errorMessage.includes('NetworkError')) {
          errorMessage = 'ネットワーク接続エラー。インターネット接続を確認してください。';
        } else if (errorMessage.includes('404')) {
          errorMessage = 'ファイルが見つかりません。URLが正しいか確認してください。';
        }
        
        updateStatus(`読み込みエラー: ${errorMessage}`, 'error');
      } finally {
        setLoading(false);
      }
    }

    // シンプルなOBJパーサー（改良版）
    function parseOBJ(data) {
      const vertices = [];
      const normals = [];
      const faces = [];
      const lines = data.split('\n');
      
      console.log(`Parsing OBJ file with ${lines.length} lines`);
      
      for (const line of lines) {
        const parts = line.trim().split(/\s+/);
        
        if (parts[0] === 'v' && parts.length >= 4) {
          vertices.push(
            parseFloat(parts[1]),
            parseFloat(parts[2]),
            parseFloat(parts[3])
          );
        } else if (parts[0] === 'vn' && parts.length >= 4) {
          normals.push(
            parseFloat(parts[1]),
            parseFloat(parts[2]),
            parseFloat(parts[3])
          );
        } else if (parts[0] === 'f' && parts.length >= 4) {
          // 三角形面の処理
          for (let i = 1; i <= 3; i++) {
            const vertexData = parts[i].split('/');
            const vertexIndex = parseInt(vertexData[0]) - 1;
            faces.push(vertexIndex);
          }
          
          // 四角形の場合は追加の三角形を作成
          if (parts.length >= 5) {
            const indices = [1, 3, 4];
            for (const i of indices) {
              const vertexData = parts[i].split('/');
              const vertexIndex = parseInt(vertexData[0]) - 1;
              faces.push(vertexIndex);
            }
          }
        }
      }

      console.log(`Parsed: ${vertices.length/3} vertices, ${faces.length/3} triangles`);

      const geometry = new THREE.BufferGeometry();
      const positionArray = new Float32Array(faces.length * 3);
      
      for (let i = 0; i < faces.length; i++) {
        const vertexIndex = faces[i];
        positionArray[i * 3] = vertices[vertexIndex * 3] || 0;
        positionArray[i * 3 + 1] = vertices[vertexIndex * 3 + 1] || 0;
        positionArray[i * 3 + 2] = vertices[vertexIndex * 3 + 2] || 0;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
      geometry.computeVertexNormals();
      geometry.center();

      const material = new THREE.MeshLambertMaterial({ 
        color: 0x888888,
        side: THREE.DoubleSide
      });
      
      return new THREE.Mesh(geometry, material);
    }

    // STLパーサー（ASCII対応）
    function parseSTL(data) {
      const vertices = [];
      const lines = data.split('\n');
      
      console.log(`Parsing STL file with ${lines.length} lines`);
      
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith('vertex')) {
          const parts = trimmed.split(/\s+/);
          if (parts.length >= 4) {
            vertices.push(
              parseFloat(parts[1]),
              parseFloat(parts[2]),
              parseFloat(parts[3])
            );
          }
        }
      }

      console.log(`Parsed STL: ${vertices.length/3} vertices`);

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
      geometry.computeVertexNormals();
      geometry.center();

      const material = new THREE.MeshLambertMaterial({ 
        color: 0x888888,
        side: THREE.DoubleSide
      });
      
      return new THREE.Mesh(geometry, material);
    }

    // ファイル読み込み（改良版）
    function loadFromFile(file) {
      if (isLoading || !file) return;
      
      setLoading(true);
      const format = detectFileFormat('', file.name);
      updateStatus(`ローカル${format.toUpperCase()}ファイルを読み込み中...`, 'warning');
      
      const reader = new FileReader();
      
      reader.onload = function(e) {
        try {
          const data = e.target.result;

          // モデルクリア
          if (currentModel) {
            scene.remove(currentModel);
            currentModel = null;
          }

          // パース
          if (format === 'obj') {
            currentModel = parseOBJ(data);
          } else if (format === 'stl') {
            currentModel = parseSTL(data);
          } else {
            throw new Error('対応していないファイル形式です');
          }

          if (currentModel) {
            scene.add(currentModel);
            
            // 位置とカメラ調整
            const box = new THREE.Box3().setFromObject(currentModel);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            // VR用により遠い距離
            const vrDistance = maxDim * 5;
            camera.position.set(0, 1.6, vrDistance);
            
            updateStatus(`ファイル読み込み完了！ (${format.toUpperCase()}, ${file.name}, VR距離: ${vrDistance.toFixed(2)})`, 'success');
          }

        } catch (error) {
          console.error('File processing error:', error);
          updateStatus('ファイル処理エラー: ' + error.message, 'error');
        } finally {
          setLoading(false);
        }
      };
      
      reader.onerror = function() {
        updateStatus('ファイル読み込みエラー', 'error');
        setLoading(false);
      };
      
      reader.readAsText(file);
    }

    // イベントリスナー設定
    function setupEventListeners() {
      console.log('Setting up event listeners...');
      
      loadBtn.onclick = function() {
        console.log('Load button clicked, URL:', urlInput.value);
        const url = urlInput.value.trim();
        if (url) {
          // dropbox URLは必ずプロキシ経由で読み込み
          const useProxy = url.includes('dropbox.com');
          loadModel(url, useProxy);
        } else {
          updateStatus('URLを入力してください', 'warning');
        }
      };

      pasteBtn.onclick = async function() {
        console.log('Paste button clicked');
        try {
          const text = await navigator.clipboard.readText();
          urlInput.value = text;
          updateStatus('クリップボードからURLを貼り付けました', 'success');
        } catch (error) {
          console.error('Paste error:', error);
          updateStatus('貼り付けエラー: ' + error.message, 'error');
        }
      };

      fileBtn.onclick = function() {
        console.log('File button clicked');
        fileInput.click();
      };

      resetBtn.onclick = function() {
        console.log('Reset button clicked');
        if (currentModel) {
          scene.remove(currentModel);
          currentModel = null;
          updateStatus('モデルをリセットしました', 'success');
        }
        camera.position.set(0, 1.6, 8); // VR用により遠い位置
        urlInput.value = '';
      };

      fileInput.onchange = function(e) {
        const file = e.target.files[0];
        if (file) {
          console.log('File selected:', file.name);
          loadFromFile(file);
        }
      };

      // モデル操作ボタン
      rotateL.onclick = () => { if (currentModel) currentModel.rotation.y -= Math.PI / 8; };
      rotateR.onclick = () => { if (currentModel) currentModel.rotation.y += Math.PI / 8; };
      rotateUp.onclick = () => { if (currentModel) currentModel.rotation.x -= Math.PI / 8; };
      rotateDown.onclick = () => { if (currentModel) currentModel.rotation.x += Math.PI / 8; };
      scaleUp.onclick = () => { if (currentModel) currentModel.scale.multiplyScalar(1.2); };
      scaleDown.onclick = () => { if (currentModel) currentModel.scale.multiplyScalar(0.8); };

      // ドラッグ&ドロップ
      document.addEventListener('dragover', function(e) {
        e.preventDefault();
        dropZone.style.display = 'grid';
      });

      document.addEventListener('dragleave', function(e) {
        if (!e.relatedTarget) dropZone.style.display = 'none';
      });

      document.addEventListener('drop', function(e) {
        e.preventDefault();
        dropZone.style.display = 'none';
        const file = e.dataTransfer.files[0];
        if (file) loadFromFile(file);
      });

      // リサイズ
      window.addEventListener('resize', function() {
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });
    }

    // 初期化
    console.log('Initializing PICO4 WebXR Viewer...');
    updateStatus('アプリケーションを初期化中...', 'warning');
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function() {
        setupEventListeners();
        initThreeJS();
      });
    } else {
      setupEventListeners();
      initThreeJS();
    }

    // グローバルエラーハンドリング
    window.addEventListener('error', function(e) {
      console.error('Global error:', e);
      updateStatus('エラー: ' + e.message, 'error');
    });

    window.addEventListener('unhandledrejection', function(e) {
      console.error('Unhandled promise rejection:', e);
      updateStatus('非同期エラー: ' + e.reason, 'error');
    });

  </script>
</body>
</html>
