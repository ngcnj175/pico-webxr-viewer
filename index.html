<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>WebXR 3D Viewer for PICO4 (Fixed)</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0d10;color:#e8eef8;font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
    #ui{position:fixed;left:0;right:0;top:0;display:grid;grid-template-columns:1fr;gap:.5rem;padding:.75rem;background:linear-gradient(180deg, rgba(0,0,0,.75), rgba(0,0,0,.3));backdrop-filter: blur(6px);z-index:10}
    #row1,#row2{display:flex; gap:.5rem; align-items:center; flex-wrap:wrap}
    #url,#mtl{flex:1;min-width:200px;padding:.6rem;border-radius:.6rem;border:1px solid #2a2f3a;background:#141821;color:#e8eef8;font-size:14px}
    select,button{padding:.6rem .8rem;border-radius:.6rem;border:1px solid #2a2f3a;background:#1b2130;color:#e8eef8;cursor:pointer;font-size:14px;white-space:nowrap}
    button:hover{background:#222a3d}
    button:active{background:#2a3441}
    button:disabled{opacity:0.5;cursor:not-allowed}
    #status{font-size:.85rem;opacity:.85;padding:.5rem;background:rgba(0,0,0,.3);border-radius:.4rem;margin:.5rem 0}
    .error{color:#ff6b6b;background:rgba(255,107,107,.1)}
    .success{color:#51cf66;background:rgba(81,207,102,.1)}
    .warning{color:#ffd43b;background:rgba(255,212,59,.1)}
    #drop{position:fixed;inset:0;border:3px dashed #3b82f6;border-radius:1rem;margin:1rem;display:none;place-content:center;color:#3b82f6;background:rgba(59,130,246,.08);z-index:20;font-size:1.2rem;font-weight:bold}
    #corsInfo{background:rgba(59,130,246,.1);border:1px solid #3b82f6;border-radius:.6rem;padding:1rem;margin:.5rem 0;font-size:.85rem}
    .hidden{display:none!important}
    @media (max-width: 768px) {
      #ui{font-size:14px}
      #row1,#row2{flex-direction:column;align-items:stretch}
      #url,#mtl,select,button{min-width:unset;width:100%}
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="row1">
      <select id="fmt">
        <option value="glb">GLB/GLTF</option>
        <option value="obj">OBJ (+MTLä»»æ„)</option>
        <option value="stl">STL</option>
      </select>
      <input id="url" placeholder="3Dãƒ¢ãƒ‡ãƒ«ã®URLï¼ˆç›´ãƒªãƒ³ã‚¯å¿…é ˆï¼‰" />
      <input id="mtl" placeholder="ï¼ˆä»»æ„ï¼‰OBJç”¨MTLã®URL" class="hidden" />
      <button id="load">èª­ã¿è¾¼ã‚€</button>
      <button id="proxy" title="CORSå›é¿ç”¨ãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§èª­ã¿è¾¼ã¿">ãƒ—ãƒ­ã‚­ã‚·çµŒç”±</button>
    </div>
    <div id="row2">
      <button id="filebtn">ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«</button>
      <button id="reset">ãƒªã‚»ãƒƒãƒˆ</button>
      <button id="rotL">âŸ²</button>
      <button id="rotR">âŸ³</button>
      <button id="scaleP">æ‹¡å¤§ +</button>
      <button id="scaleM">ç¸®å° âˆ’</button>
    </div>
    <div id="status">æº–å‚™å®Œäº†ã€‚3Dãƒ¢ãƒ‡ãƒ«ã®URLã‚’å…¥åŠ›ã—ã¦èª­ã¿è¾¼ã‚“ã§ãã ã•ã„ã€‚</div>
    <div id="corsInfo">
      <strong>ğŸ”§ Dropboxä½¿ç”¨æ™‚ã®æ³¨æ„:</strong><br>
      â€¢ URLã®æœ«å°¾ã‚’ <code>?raw=1</code> ã¾ãŸã¯ <code>?dl=1</code> ã«å¤‰æ›´<br>
      â€¢ ãã‚Œã§ã‚‚èª­ã¿è¾¼ã‚ãªã„å ´åˆã¯ã€Œãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã€ãƒœã‚¿ãƒ³ã‚’ä½¿ç”¨<br>
      â€¢ ç¢ºå®Ÿãªæ–¹æ³•: ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯è‡ªå‰ã‚µãƒ¼ãƒãƒ¼ã‚’ä½¿ç”¨<br>
      <strong>VRæ“ä½œ:</strong> ã‚¹ãƒ†ã‚£ãƒƒã‚¯å·¦å³=å›è»¢ã€ä¸Šä¸‹=æ‹¡å¤§ç¸®å°
    </div>
    <input id="file" type="file" accept=".glb,.gltf,.obj,.stl,model/gltf-binary" hidden />
  </div>
  <div id="drop">ã“ã“ã« 3D ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ­ãƒƒãƒ—</div>
 
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
    import { OBJLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/OBJLoader.js';
    import { MTLLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/MTLLoader.js';
    import { STLLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/STLLoader.js';
    import { VRButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/VRButton.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    let scene, camera, renderer, controls, currentObj;
    const container = document.body;

    // UIè¦ç´ 
    const statusDiv = document.getElementById('status');
    const loadBtn = document.getElementById('load');
    const proxyBtn = document.getElementById('proxy');
    const resetBtn = document.getElementById('reset');

    function updateStatus(message, type = 'info') {
      statusDiv.textContent = message;
      statusDiv.className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : '';
      console.log(`[${type.toUpperCase()}]`, message);
    }

    function setLoading(isLoading) {
      [loadBtn, proxyBtn].forEach(btn => btn.disabled = isLoading);
      if (isLoading) updateStatus('èª­ã¿è¾¼ã¿ä¸­...', 'warning');
    }

    // Three.jsåˆæœŸåŒ–
    try {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0d10);

      camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 3);

      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2)); // PICO4ã§ã®æ€§èƒ½è€ƒæ…®
      renderer.setSize(innerWidth, innerHeight);
      renderer.xr.enabled = true;
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      
      container.appendChild(renderer.domElement);

      // WebXRãƒœã‚¿ãƒ³è¿½åŠ ï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ãï¼‰
      try {
        const vrButton = VRButton.createButton(renderer);
        vrButton.style.bottom = '20px';
        vrButton.style.right = '20px';
        container.appendChild(vrButton);
        updateStatus('WebXRå¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶ã§ã™ã€‚VRãƒœã‚¿ãƒ³ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚', 'success');
      } catch(e) {
        updateStatus('WebXRéå¯¾å¿œã¾ãŸã¯VRãƒœã‚¿ãƒ³è¿½åŠ ã‚¨ãƒ©ãƒ¼: ' + e.message, 'warning');
      }

      // ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 10, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      scene.add(directionalLight);

      // ã‚°ãƒªãƒƒãƒ‰
      const gridHelper = new THREE.GridHelper(20, 20, 0x334155, 0x1f2937);
      scene.add(gridHelper);

      // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxDistance = 50;
      controls.minDistance = 0.5;

      updateStatus('3Dã‚¨ãƒ³ã‚¸ãƒ³åˆæœŸåŒ–å®Œäº†', 'success');
    } catch(e) {
      updateStatus('3Dã‚¨ãƒ³ã‚¸ãƒ³åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ' + e.message, 'error');
    }

    // ãƒ­ãƒ¼ãƒ€ãƒ¼åˆæœŸåŒ–
    const gltfLoader = new GLTFLoader();
    const objLoader = new OBJLoader();
    const mtlLoader = new MTLLoader();
    const stlLoader = new STLLoader();

    function clearModel(){
      if(currentObj){ 
        scene.remove(currentObj); 
        currentObj = null;
        updateStatus('ãƒ¢ãƒ‡ãƒ«ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
      }
    }

    function frameObject(obj){
      const box = new THREE.Box3().setFromObject(obj);
      const size = new THREE.Vector3(); 
      box.getSize(size);
      const center = new THREE.Vector3(); 
      box.getCenter(center);
      
      // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¸­å¿ƒã«ç§»å‹•
      obj.position.sub(center);
      
      // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’èª¿æ•´
      const maxDim = Math.max(size.x, size.y, size.z) || 1;
      const distance = maxDim * 2;
      camera.position.set(distance * 0.7, distance * 0.5, distance);
      controls.target.set(0, 0, 0);
      controls.update();
      
      updateStatus(`ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº† (ã‚µã‚¤ã‚º: ${maxDim.toFixed(2)})`, 'success');
    }

    // URLæ­£è¦åŒ–é–¢æ•°ï¼ˆæ”¹è‰¯ç‰ˆï¼‰
    function normalizeURL(url) {
      if (!url) return url;
      
      // Dropboxå¯¾å¿œ
      if (url.includes('dropbox.com')) {
        // æ—¢å­˜ã®ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦ raw=1 ã‚’è¿½åŠ 
        let cleanUrl = url.split('?')[0];
        return cleanUrl + '?raw=1';
      }
      
      // Google Driveå¯¾å¿œ
      if (url.includes('drive.google.com')) {
        const match = url.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
        if (match) {
          return `https://drive.google.com/uc?export=download&id=${match[1]}`;
        }
      }
      
      return url;
    }

    // CORSå›é¿ãƒ—ãƒ­ã‚­ã‚·URL
    const CORS_PROXIES = [
      'https://cors-anywhere.herokuapp.com/',
      'https://api.allorigins.win/raw?url=',
      'https://corsproxy.io/?'
    ];

    async function loadFromURL(url, format, mtlUrl, useProxy = false) {
      if (!url?.trim()) {
        updateStatus('URLãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
        return;
      }

      setLoading(true);
      
      try {
        clearModel();
        
        // URLæ­£è¦åŒ–
        let normalizedUrl = normalizeURL(url.trim());
        let normalizedMtlUrl = mtlUrl ? normalizeURL(mtlUrl.trim()) : null;
        
        // ãƒ—ãƒ­ã‚­ã‚·ä½¿ç”¨
        if (useProxy) {
          const proxy = CORS_PROXIES[0]; // æœ€åˆã®ãƒ—ãƒ­ã‚­ã‚·ã‚’ä½¿ç”¨
          normalizedUrl = proxy + encodeURIComponent(normalizedUrl);
          if (normalizedMtlUrl) {
            normalizedMtlUrl = proxy + encodeURIComponent(normalizedMtlUrl);
          }
          updateStatus('ãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§èª­ã¿è¾¼ã¿ä¸­...', 'warning');
        } else {
          updateStatus(`${format.toUpperCase()}ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...`, 'warning');
        }

        let loadedObject = null;

        if (format === 'glb') {
          const gltf = await gltfLoader.loadAsync(normalizedUrl);
          loadedObject = gltf.scene;
          
          // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã‚‹å ´åˆã®å‡¦ç†
          if (gltf.animations?.length > 0) {
            updateStatus(`ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ããƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº† (${gltf.animations.length}å€‹)`, 'success');
          }
          
        } else if (format === 'obj') {
          // MTLãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹å ´åˆã¯å…ˆã«èª­ã¿è¾¼ã¿
          if (normalizedMtlUrl) {
            try {
              const materials = await mtlLoader.loadAsync(normalizedMtlUrl);
              materials.preload();
              objLoader.setMaterials(materials);
              updateStatus('ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å®Œäº†ã€OBJãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...', 'warning');
            } catch(mtlError) {
              updateStatus('MTLãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å¤±æ•—ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒ†ãƒªã‚¢ãƒ«ã§ç¶šè¡Œ', 'warning');
            }
          }
          
          loadedObject = await objLoader.loadAsync(normalizedUrl);
          
        } else if (format === 'stl') {
          const geometry = await stlLoader.loadAsync(normalizedUrl);
          geometry.computeVertexNormals();
          
          const material = new THREE.MeshStandardMaterial({
            color: 0x9aa7b1,
            metalness: 0.1,
            roughness: 0.8
          });
          
          loadedObject = new THREE.Mesh(geometry, material);
          loadedObject.castShadow = true;
          loadedObject.receiveShadow = true;
        }

        if (loadedObject) {
          // ã‚·ãƒ£ãƒ‰ã‚¦è¨­å®š
          loadedObject.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          
          currentObj = loadedObject;
          scene.add(loadedObject);
          frameObject(loadedObject);
          
          // æˆåŠŸæ™‚ã®ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä¿å­˜
          localStorage.setItem('last_model_url', url);
          localStorage.setItem('last_model_format', format);
          if (mtlUrl) localStorage.setItem('last_mtl_url', mtlUrl);
          
        } else {
          throw new Error('ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
        }
        
      } catch (error) {
        console.error('Load error:', error);
        let errorMessage = 'ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ';
        
        if (error.message.includes('CORS')) {
          errorMessage += 'CORSåˆ¶é™ã«ã‚ˆã‚Šã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“ã€‚ã€Œãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã€ãƒœã‚¿ãƒ³ã‚’è©¦ã—ã¦ãã ã•ã„ã€‚';
        } else if (error.message.includes('404')) {
          errorMessage += 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚URLã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
        } else if (error.message.includes('NetworkError')) {
          errorMessage += 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã§ã™ã€‚æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
        } else {
          errorMessage += error.message || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
        }
        
        updateStatus(errorMessage, 'error');
        
        // å¤±æ•—æ™‚ã¯ãƒ—ãƒ­ã‚­ã‚·ä½¿ç”¨ã‚’ææ¡ˆ
        if (!useProxy && error.message.includes('CORS')) {
          updateStatus('CORSåˆ¶é™ã‚¨ãƒ©ãƒ¼ - ãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§ã®èª­ã¿è¾¼ã¿ã‚’è©¦ã—ã¦ãã ã•ã„', 'warning');
        }
      } finally {
        setLoading(false);
      }
    }

    async function loadFromFile(file) {
      if (!file) return;
      
      setLoading(true);
      updateStatus('ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...', 'warning');
      
      try {
        clearModel();
        const url = URL.createObjectURL(file);
        const fileExt = file.name.toLowerCase().split('.').pop();
        
        let loadedObject = null;
        
        if (['glb', 'gltf'].includes(fileExt)) {
          const gltf = await gltfLoader.loadAsync(url);
          loadedObject = gltf.scene;
        } else if (fileExt === 'obj') {
          loadedObject = await objLoader.loadAsync(url);
        } else if (fileExt === 'stl') {
          const geometry = await stlLoader.loadAsync(url);
          geometry.computeVertexNormals();
          const material = new THREE.MeshStandardMaterial({
            color: 0x9aa7b1,
            metalness: 0.1,
            roughness: 0.8
          });
          loadedObject = new THREE.Mesh(geometry, material);
        } else {
          throw new Error('ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™');
        }
        
        if (loadedObject) {
          currentObj = loadedObject;
          scene.add(loadedObject);
          frameObject(loadedObject);
        }
        
        // URLã‚’è§£æ”¾
        setTimeout(() => URL.revokeObjectURL(url), 10000);
        
      } catch (error) {
        console.error('File load error:', error);
        updateStatus('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ' + (error?.message || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼'), 'error');
      } finally {
        setLoading(false);
      }
    }

    // UIè¦ç´ ã®å–å¾—
    const fmtSelect = document.getElementById('fmt');
    const urlInput = document.getElementById('url');
    const mtlInput = document.getElementById('mtl');
    const fileBtnEl = document.getElementById('filebtn');
    const fileInput = document.getElementById('file');
    const dropZone = document.getElementById('drop');
    const rotLBtn = document.getElementById('rotL');
    const rotRBtn = document.getElementById('rotR');
    const scalePBtn = document.getElementById('scaleP');
    const scaleMBtn = document.getElementById('scaleM');

    // åˆæœŸå€¤ã®å¾©å…ƒ
    urlInput.value = localStorage.getItem('last_model_url') || '';
    mtlInput.value = localStorage.getItem('last_mtl_url') || '';
    fmtSelect.value = localStorage.getItem('last_model_format') || 'glb';

    // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆå¤‰æ›´æ™‚ã®å‡¦ç†
    fmtSelect.addEventListener('change', () => {
      const isObj = fmtSelect.value === 'obj';
      if (isObj) {
        mtlInput.classList.remove('hidden');
      } else {
        mtlInput.classList.add('hidden');
      }
    });
    fmtSelect.dispatchEvent(new Event('change'));

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    loadBtn.addEventListener('click', () => {
      loadFromURL(urlInput.value, fmtSelect.value, mtlInput.value, false);
    });

    proxyBtn.addEventListener('click', () => {
      loadFromURL(urlInput.value, fmtSelect.value, mtlInput.value, true);
    });

    fileBtnEl.addEventListener('click', () => fileInput.click());
    
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files?.[0];
      if (file) loadFromFile(file);
    });

    resetBtn.addEventListener('click', () => {
      clearModel();
      urlInput.value = '';
      mtlInput.value = '';
      localStorage.removeItem('last_model_url');
      localStorage.removeItem('last_mtl_url');
      localStorage.removeItem('last_model_format');
      camera.position.set(0, 1.6, 3);
      controls.reset();
      updateStatus('ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ');
    });

    // ãƒ¢ãƒ‡ãƒ«æ“ä½œ
    const getCurrentObject = () => currentObj;
    
    rotLBtn.addEventListener('click', () => {
      const obj = getCurrentObject();
      if (obj) {
        obj.rotation.y -= Math.PI / 12;
        updateStatus('ãƒ¢ãƒ‡ãƒ«ã‚’å›è»¢ã•ã›ã¾ã—ãŸ');
      }
    });
    
    rotRBtn.addEventListener('click', () => {
      const obj = getCurrentObject();
      if (obj) {
        obj.rotation.y += Math.PI / 12;
        updateStatus('ãƒ¢ãƒ‡ãƒ«ã‚’å›è»¢ã•ã›ã¾ã—ãŸ');
      }
    });
    
    scalePBtn.addEventListener('click', () => {
      const obj = getCurrentObject();
      if (obj) {
        obj.scale.multiplyScalar(1.1);
        updateStatus('ãƒ¢ãƒ‡ãƒ«ã‚’æ‹¡å¤§ã—ã¾ã—ãŸ');
      }
    });
    
    scaleMBtn.addEventListener('click', () => {
      const obj = getCurrentObject();
      if (obj) {
        obj.scale.multiplyScalar(0.9);
        updateStatus('ãƒ¢ãƒ‡ãƒ«ã‚’ç¸®å°ã—ã¾ã—ãŸ');
      }
    });

    // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
    window.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.style.display = 'grid';
    });

    window.addEventListener('dragleave', (e) => {
      if (!e.relatedTarget || !container.contains(e.relatedTarget)) {
        dropZone.style.display = 'none';
      }
    });

    window.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.style.display = 'none';
      const file = e.dataTransfer.files?.[0];
      if (file) loadFromFile(file);
    });

    // WebXRã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
    function applyXRGamepadControls() {
      if (!renderer.xr.isPresenting) return;
      
      const session = renderer.xr.getSession();
      if (!session) return;
      
      const obj = getCurrentObject();
      if (!obj) return;
      
      const DEADZONE = 0.15;
      const ROTATION_SPEED = 0.04;
      const SCALE_SPEED = 0.015;
      
      for (const inputSource of session.inputSources) {
        const gamepad = inputSource.gamepad;
        if (!gamepad || !gamepad.axes) continue;
        
        // æ°´å¹³è»¸ï¼ˆå›è»¢ï¼‰
        const horizontalAxis = gamepad.axes[2] ?? gamepad.axes[0] ?? 0;
        if (Math.abs(horizontalAxis) > DEADZONE) {
          obj.rotation.y += horizontalAxis * ROTATION_SPEED;
        }
        
        // å‚ç›´è»¸ï¼ˆã‚¹ã‚±ãƒ¼ãƒ«ï¼‰
        const verticalAxis = gamepad.axes[3] ?? gamepad.axes[1] ?? 0;
        if (Math.abs(verticalAxis) > DEADZONE) {
          const scaleMultiplier = 1 + (-verticalAxis) * SCALE_SPEED;
          obj.scale.multiplyScalar(scaleMultiplier);
          obj.scale.clampScalar(0.1, 20);
        }
      }
    }

    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—
    function animate() {
      controls.update();
      applyXRGamepadControls();
      renderer.render(scene, camera);
    }

    renderer.setAnimationLoop(animate);

    // ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
    window.addEventListener('resize', () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    });

    // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
    window.addEventListener('error', (e) => {
      updateStatus('JavaScriptã‚¨ãƒ©ãƒ¼: ' + e.message, 'error');
    });

    window.addEventListener('unhandledrejection', (e) => {
      updateStatus('Promiseæ‹’å¦: ' + e.reason, 'error');
    });

    // åˆæœŸåŒ–å®Œäº†
    updateStatus('WebXR 3Dãƒ“ãƒ¥ãƒ¼ãƒ¯ãƒ¼åˆæœŸåŒ–å®Œäº†ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„ã€‚', 'success');

  </script>
</body>
</html>
