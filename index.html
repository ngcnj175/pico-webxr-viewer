<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>PICO4 WebXR 3D Viewer (Fixed VR)</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0d10;color:#e8eef8;font-family:Arial, sans-serif}
    #ui{position:fixed;left:10px;right:10px;top:10px;background:rgba(0,0,0,0.9);padding:15px;border-radius:8px;z-index:100}
    #controls{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:10px}
    #url{flex:1;min-width:200px;padding:8px;border:1px solid #444;background:#222;color:#fff;border-radius:4px}
    button{padding:8px 12px;border:1px solid #444;background:#333;color:#fff;border-radius:4px;cursor:pointer}
    button:hover{background:#555}
    button:disabled{background:#111;color:#666;cursor:not-allowed}
    #vrButton{position:fixed!important;bottom:20px!important;right:20px!important;padding:15px 25px!important;background:#1976d2!important;color:white!important;border:none!important;border-radius:8px!important;font-size:16px!important;font-weight:bold!important;cursor:pointer!important;z-index:200!important}
    #vrButton:hover{background:#1565c0!important}
    #status{background:#111;padding:8px;border-radius:4px;font-size:12px;margin-top:10px;border-left:4px solid #666}
    .error{border-left-color:#ff4444}
    .success{border-left-color:#44ff44}
    .warning{border-left-color:#ffff44}
    #fileInput{display:none}
    #dropZone{position:fixed;inset:0;border:3px dashed #44f;display:none;place-content:center;background:rgba(0,100,255,0.1);z-index:50;font-size:24px;color:#44f}
    #corsHelp{background:rgba(255,193,7,0.1);border:1px solid #ffc107;border-radius:4px;padding:8px;margin:5px 0;font-size:11px}
  </style>
</head>
<body>
  <div id="ui">
    <div id="controls">
      <input id="url" placeholder="3D Model URL (.obj/.glb/.stl)" value="">
      <button id="pasteBtn">è²¼ã‚Šä»˜ã‘</button>
      <button id="loadBtn">èª­ã¿è¾¼ã‚€</button>
      <button id="fileBtn">ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ</button>
      <button id="resetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
    </div>
    <div id="controls">
      <button id="rotateL">âŸ² å·¦å›è»¢</button>
      <button id="rotateR">âŸ³ å³å›è»¢</button>
      <button id="rotateUp">â†‘ ä¸Šå›è»¢</button>
      <button id="rotateDown">â†“ ä¸‹å›è»¢</button>
      <button id="scaleUp">æ‹¡å¤§ +</button>
      <button id="scaleDown">ç¸®å° -</button>
    </div>
    <div id="corsHelp">
      ğŸ® <strong>VRæ“ä½œæ–¹æ³• (PICO4):</strong><br>
      â€¢ <strong>å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯:</strong> è¦–ç‚¹ç§»å‹• (ä¸Šä¸‹=Yè»¸ç§»å‹•ã€å·¦å³=Xè»¸ç§»å‹•)<br>
      â€¢ <strong>å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯:</strong> ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå›è»¢ (ä¸Šä¸‹=Xè»¸å›è»¢ã€å·¦å³=Yè»¸å›è»¢)<br>
      â€¢ <strong>Yãƒœã‚¿ãƒ³:</strong> è¦–ç‚¹å‰é€² | <strong>Xãƒœã‚¿ãƒ³:</strong> è¦–ç‚¹å¾Œé€€<br>
      â€¢ <strong>Aãƒœã‚¿ãƒ³:</strong> ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç¸®å° | <strong>Bãƒœã‚¿ãƒ³:</strong> ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ‹¡å¤§<br>
      ğŸ“ <strong>èª­ã¿è¾¼ã¿:</strong> ã€Œèª­ã¿è¾¼ã‚€ã€ãƒœã‚¿ãƒ³ã§è‡ªå‹•çš„ã«CORSåˆ¶é™å›é¿
    </div>
    <div id="status">æº–å‚™å®Œäº† - URLã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„</div>
  </div>

  <input type="file" id="fileInput" accept=".obj,.glb,.gltf,.stl">
  <div id="dropZone">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦ãã ã•ã„</div>

  <script>
    console.log('PICO4 WebXR Viewer - Script starting...');
    
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
    let scene, camera, renderer, controls, currentModel;
    let isLoading = false;
    let vrSession = null;
    
    // UIè¦ç´ ã‚’å–å¾—
    const statusEl = document.getElementById('status');
    const urlInput = document.getElementById('url');
    const loadBtn = document.getElementById('loadBtn');
    const pasteBtn = document.getElementById('pasteBtn');
    const fileBtn = document.getElementById('fileBtn');
    const resetBtn = document.getElementById('resetBtn');
    const fileInput = document.getElementById('fileInput');
    const dropZone = document.getElementById('dropZone');
    const rotateL = document.getElementById('rotateL');
    const rotateR = document.getElementById('rotateR');
    const rotateUp = document.getElementById('rotateUp');
    const rotateDown = document.getElementById('rotateDown');
    const scaleUp = document.getElementById('scaleUp');
    const scaleDown = document.getElementById('scaleDown');

    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°é–¢æ•°
    function updateStatus(message, type) {
      console.log('Status:', message, type);
      statusEl.textContent = message;
      statusEl.className = type || '';
    }

    // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ç®¡ç†
    function setLoading(loading) {
      isLoading = loading;
      loadBtn.disabled = loading;
      pasteBtn.disabled = loading;
      if (loading) {
        updateStatus('èª­ã¿è¾¼ã¿ä¸­...', 'warning');
      }
    }

    // ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã®è‡ªå‹•åˆ¤åˆ¥
    function detectFileFormat(url, filename) {
      const name = (filename || url || '').toLowerCase();
      if (name.includes('.obj')) return 'obj';
      if (name.includes('.glb') || name.includes('.gltf')) return 'glb';
      if (name.includes('.stl')) return 'stl';
      return 'obj'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    }

    // ã‚ˆã‚Šç¢ºå®ŸãªDropbox URLå¤‰æ›
    function fixDropboxURL(url) {
      if (!url || !url.includes('dropbox.com')) return url;
      
      console.log('Original Dropbox URL:', url);
      
      // Dropboxã®æ–°ã—ã„å…±æœ‰ãƒªãƒ³ã‚¯å½¢å¼ã‚’ç›´æ¥ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯ã«å¤‰æ›
      if (url.includes('/scl/fi/')) {
        // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å…¨ã¦å‰Šé™¤ã—ã¦ raw=1 ã®ã¿ã«ã™ã‚‹
        const baseUrl = url.split('?')[0];
        const params = new URLSearchParams(url.split('?')[1] || '');
        const rlkey = params.get('rlkey');
        
        if (rlkey) {
          const newUrl = `${baseUrl}?rlkey=${rlkey}&raw=1`;
          console.log('Fixed Dropbox URL:', newUrl);
          return newUrl;
        }
      }
      
      // å¾“æ¥ã®å½¢å¼
      const baseUrl = url.split('?')[0];
      const newUrl = baseUrl + '?raw=1';
      console.log('Fixed traditional Dropbox URL:', newUrl);
      return newUrl;
    }

    // Three.jsã®åˆæœŸåŒ–
    function initThreeJS() {
      try {
        console.log('Loading Three.js...');
        updateStatus('3Dã‚¨ãƒ³ã‚¸ãƒ³ã‚’åˆæœŸåŒ–ä¸­...', 'warning');
        
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
        script.onload = function() {
          console.log('Three.js loaded successfully');
          setupScene();
        };
        script.onerror = function() {
          updateStatus('Three.jsèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ - ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„', 'error');
        };
        document.head.appendChild(script);
        
      } catch (error) {
        console.error('Init error:', error);
        updateStatus('åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
      }
    }

    // ã‚·ãƒ¼ãƒ³è¨­å®š
    function setupScene() {
      try {
        console.log('Setting up 3D scene...');
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0b0d10);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 8); // ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ç”¨åˆæœŸä½ç½®

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true; // WebXRæœ‰åŠ¹åŒ–
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        // VRãƒœã‚¿ãƒ³ã®ä½œæˆã¨è¨­å®š
        createVRButton();

        // ãƒ©ã‚¤ãƒˆè¨­å®š
        const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(10, 10, 5);
        scene.add(directionalLight);

        // åºŠã®ã‚°ãƒªãƒƒãƒ‰
        const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
        scene.add(gridHelper);

        // ãƒã‚¦ã‚¹ãƒ»ã‚¿ãƒƒãƒæ“ä½œã®è¨­å®š
        setupControls();

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—é–‹å§‹
        renderer.setAnimationLoop(animate);

        updateStatus('3Dã‚¨ãƒ³ã‚¸ãƒ³åˆæœŸåŒ–å®Œäº† - VRãƒœã‚¿ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„', 'success');
        
      } catch (error) {
        console.error('Scene setup error:', error);
        updateStatus('ã‚·ãƒ¼ãƒ³è¨­å®šã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
      }
    }

    // VRãƒœã‚¿ãƒ³ã®ä½œæˆï¼ˆPICO4å¯¾å¿œï¼‰
    function createVRButton() {
      console.log('Creating VR button...');
      
      const vrButton = document.createElement('button');
      vrButton.id = 'vrButton';
      vrButton.textContent = 'Enter VR';
      document.body.appendChild(vrButton);

      // WebXRå¯¾å¿œãƒã‚§ãƒƒã‚¯
      if ('xr' in navigator) {
        console.log('WebXR API found');
        
        navigator.xr.isSessionSupported('immersive-vr')
          .then(function(supported) {
            console.log('VR supported:', supported);
            if (supported) {
              vrButton.style.display = 'block';
              updateStatus('VRãƒ‡ãƒã‚¤ã‚¹å¯¾å¿œç¢ºèªæ¸ˆã¿ - Enter VRãƒœã‚¿ãƒ³ãŒåˆ©ç”¨å¯èƒ½ã§ã™', 'success');
              
              vrButton.onclick = function() {
                console.log('VR button clicked');
                toggleVR();
              };
            } else {
              vrButton.style.display = 'none';
              updateStatus('VRãƒ‡ãƒã‚¤ã‚¹ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã¾ã›ã‚“', 'warning');
            }
          })
          .catch(function(error) {
            console.error('VR support check failed:', error);
            vrButton.style.display = 'none';
            updateStatus('VRå¯¾å¿œãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
          });
      } else {
        console.log('WebXR API not found');
        vrButton.style.display = 'none';
        updateStatus('WebXRéå¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶ã§ã™', 'warning');
      }
    }

    // VRã‚»ãƒƒã‚·ãƒ§ãƒ³ã®é–‹å§‹æ™‚ã«ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’èª¿æ•´
    async function toggleVR() {
      try {
        console.log('Toggling VR mode...');
        
        if (vrSession) {
          console.log('Ending VR session');
          await vrSession.end();
        } else {
          console.log('Starting VR session');
          updateStatus('VRã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é–‹å§‹ä¸­...', 'warning');
          
          vrSession = await navigator.xr.requestSession('immersive-vr', {
            optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking']
          });
          
          console.log('VR session started');
          
          vrSession.addEventListener('end', function() {
            console.log('VR session ended');
            vrSession = null;
            document.getElementById('vrButton').textContent = 'Enter VR';
            updateStatus('VRãƒ¢ãƒ¼ãƒ‰ã‚’çµ‚äº†ã—ã¾ã—ãŸ', 'success');
          });

          await renderer.xr.setSession(vrSession);
          
          // VRãƒ¢ãƒ¼ãƒ‰é–‹å§‹æ™‚ã«ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’èª¿æ•´
          if (currentModel) {
            const box = new THREE.Box3().setFromObject(currentModel);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            
            // VRç”¨è¦–ç‚¹: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ãŒè¦‹ãˆã‚‹ã‚ˆã†ã«æ‰‹å‰ã«é…ç½®ï¼ˆYè»¸ã¯åŒã˜é«˜ã•ï¼‰
            camera.position.set(0, 0, maxDim * 3); // æ‰‹å‰ï¼ˆZè»¸+æ–¹å‘ï¼‰ã«é…ç½®
            console.log(`VR camera position set to: x=0, y=0, z=${maxDim * 3}`);
          }
          
          document.getElementById('vrButton').textContent = 'Exit VR';
          updateStatus('VRãƒ¢ãƒ¼ãƒ‰é–‹å§‹ - æ–°ã—ã„æ“ä½œæ–¹æ³•ã§ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã—ã¦ãã ã•ã„', 'success');
        }
      } catch (error) {
        console.error('VR toggle error:', error);
        let message = 'VRãƒ¢ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ';
        if (error.message.includes('denied')) {
          message += 'VRæ¨©é™ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
        } else if (error.message.includes('not found')) {
          message += 'VRãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚PICO4ãŒæ­£ã—ãæ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
        } else {
          message += error.message;
        }
        updateStatus(message, 'error');
      }
    }

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°
    function animate() {
      handleVRControls();
      renderer.render(scene, camera);
    }

    // VRã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼æ“ä½œï¼ˆä¿®æ­£ç‰ˆï¼‰
    function handleVRControls() {
      if (!renderer.xr.isPresenting) return;
      
      const session = renderer.xr.getSession();
      if (!session) return;

      // æ“ä½œè¨­å®š
      const DEADZONE = 0.15;
      const VIEW_SPEED = 0.1; // è¦–ç‚¹ç§»å‹•é€Ÿåº¦
      const ROTATION_SPEED = 0.05; // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå›è»¢é€Ÿåº¦
      const SCALE_FACTOR = 0.015; // ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›´é‡

      for (const inputSource of session.inputSources) {
        if (!inputSource.gamepad) continue;
        
        const gamepad = inputSource.gamepad;
        const handedness = inputSource.handedness;
        
        console.log(`Controller: ${handedness}, buttons: ${gamepad.buttons.length}, axes: ${gamepad.axes.length}`);
        
        // å·¦æ‰‹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼: è¦–ç‚¹æ“ä½œ
        if (handedness === 'left') {
          // å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯: è¦–ç‚¹ã®XYè»¸ç§»å‹•
          if (gamepad.axes && gamepad.axes.length >= 2) {
            const xAxis = gamepad.axes[0]; // å·¦å³ â†’ Xè»¸ç§»å‹•
            const yAxis = gamepad.axes[1]; // ä¸Šä¸‹ â†’ Yè»¸ç§»å‹•
            
            if (Math.abs(xAxis) > DEADZONE) {
              camera.position.x += xAxis * VIEW_SPEED;
              console.log('View X movement:', xAxis, 'Camera X:', camera.position.x.toFixed(2));
            }
            
            if (Math.abs(yAxis) > DEADZONE) {
              camera.position.y += -yAxis * VIEW_SPEED; // ä¸Šä¸‹åè»¢ï¼ˆä¸Šã§ä¸Šæ˜‡ï¼‰
              console.log('View Y movement:', -yAxis, 'Camera Y:', camera.position.y.toFixed(2));
            }
          }
          
          // ãƒœã‚¿ãƒ³æ“ä½œã‚’ãƒ‡ãƒãƒƒã‚°
          if (gamepad.buttons) {
            for (let i = 0; i < gamepad.buttons.length; i++) {
              if (gamepad.buttons[i].pressed) {
                console.log(`Left controller button ${i} pressed`);
              }
            }
          }
          
          // Yãƒœã‚¿ãƒ³: è¦–ç‚¹ã®Zè»¸+æ–¹å‘ç§»å‹•ï¼ˆå‰é€²ï¼‰- PICO4ã§ã¯é€šå¸¸ãƒœã‚¿ãƒ³3
          if (gamepad.buttons && gamepad.buttons.length > 3 && gamepad.buttons[3].pressed) {
            camera.position.z -= VIEW_SPEED; // Zè»¸+æ–¹å‘ = å‰é€²ï¼ˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«è¿‘ã¥ãï¼‰
            console.log('Y button (3): forward, Camera Z:', camera.position.z.toFixed(2));
          }
          
          // Xãƒœã‚¿ãƒ³: è¦–ç‚¹ã®Zè»¸-æ–¹å‘ç§»å‹•ï¼ˆå¾Œé€€ï¼‰- PICO4ã§ã¯é€šå¸¸ãƒœã‚¿ãƒ³2
          if (gamepad.buttons && gamepad.buttons.length > 2 && gamepad.buttons[2].pressed) {
            camera.position.z += VIEW_SPEED; // Zè»¸-æ–¹å‘ = å¾Œé€€ï¼ˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰é›¢ã‚Œã‚‹ï¼‰
            console.log('X button (2): backward, Camera Z:', camera.position.z.toFixed(2));
          }
        }
        
        // å³æ‰‹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ“ä½œ
        else if (handedness === 'right' && currentModel) {
          // å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå›è»¢
          let rightXAxis, rightYAxis;
          
          // å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®è»¸ã‚’ç‰¹å®šï¼ˆPICO4ã§ã¯ axes[2], axes[3] ã¾ãŸã¯ axes[0], axes[1]ï¼‰
          if (gamepad.axes && gamepad.axes.length >= 4) {
            rightXAxis = gamepad.axes[2]; // å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯å·¦å³
            rightYAxis = gamepad.axes[3]; // å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯ä¸Šä¸‹
          } else if (gamepad.axes && gamepad.axes.length >= 2) {
            rightXAxis = gamepad.axes[0]; // å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯å·¦å³ï¼ˆå³æ‰‹ã®å ´åˆï¼‰
            rightYAxis = gamepad.axes[1]; // å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯ä¸Šä¸‹ï¼ˆå³æ‰‹ã®å ´åˆï¼‰
          }
          
          if (rightXAxis !== undefined && rightYAxis !== undefined) {
            // å·¦å³ã§Yè»¸å›è»¢ï¼ˆæ°´å¹³å›è»¢ï¼‰- æ–¹å‘ä¿®æ­£
            if (Math.abs(rightXAxis) > DEADZONE) {
              currentModel.rotation.y += -rightXAxis * ROTATION_SPEED; // æ–¹å‘åè»¢
              console.log('Object Y rotation:', -rightXAxis, 'Current Y:', currentModel.rotation.y.toFixed(2));
            }
            
            // ä¸Šä¸‹ã§Xè»¸å›è»¢ï¼ˆå‚ç›´å›è»¢ï¼‰- æ–¹å‘ä¿®æ­£
            if (Math.abs(rightYAxis) > DEADZONE) {
              currentModel.rotation.x += rightYAxis * ROTATION_SPEED; // æ–¹å‘ä¿®æ­£ï¼ˆåè»¢ãªã—ï¼‰
              console.log('Object X rotation:', rightYAxis, 'Current X:', currentModel.rotation.x.toFixed(2));
            }
          }
          
          // ãƒœã‚¿ãƒ³æ“ä½œã‚’ãƒ‡ãƒãƒƒã‚°
          if (gamepad.buttons) {
            for (let i = 0; i < gamepad.buttons.length; i++) {
              if (gamepad.buttons[i].pressed) {
                console.log(`Right controller button ${i} pressed`);
              }
            }
          }
          
          // Aãƒœã‚¿ãƒ³: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç¸®å° - PICO4ã§ã¯é€šå¸¸ãƒœã‚¿ãƒ³0ï¼ˆãƒˆãƒªã‚¬ãƒ¼ã§ã¯ãªã„ï¼‰
          if (gamepad.buttons && gamepad.buttons.length > 0 && gamepad.buttons[0].pressed) {
            currentModel.scale.multiplyScalar(1 - SCALE_FACTOR);
            currentModel.scale.clampScalar(0.05, 20.0);
            console.log('A button (0): scale down, current scale:', currentModel.scale.x.toFixed(3));
          }
          
          // Bãƒœã‚¿ãƒ³: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ‹¡å¤§ - PICO4ã§ã¯é€šå¸¸ãƒœã‚¿ãƒ³1ï¼ˆã‚°ãƒªãƒƒãƒ—ã§ã¯ãªã„ï¼‰
          if (gamepad.buttons && gamepad.buttons.length > 1 && gamepad.buttons[1].pressed) {
            currentModel.scale.multiplyScalar(1 + SCALE_FACTOR);
            currentModel.scale.clampScalar(0.05, 20.0);
            console.log('B button (1): scale up, current scale:', currentModel.scale.x.toFixed(3));
          }
          
          // ä»–ã®ãƒœã‚¿ãƒ³ã‚‚è©¦ã™ï¼ˆPICO4ã®ãƒœã‚¿ãƒ³é…ç½®ç¢ºèªç”¨ï¼‰
          // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³ï¼ˆé€šå¸¸ãƒœã‚¿ãƒ³4ï¼‰ã§ãƒªã‚»ãƒƒãƒˆ
          if (gamepad.buttons && gamepad.buttons.length > 4 && gamepad.buttons[4].pressed) {
            currentModel.position.set(0, 0, 0);
            currentModel.rotation.set(0, 0, 0);
            currentModel.scale.set(1, 1, 1);
            console.log('Menu button (4): model reset');
          }
        }
      }
    }

    // ãƒã‚¦ã‚¹ãƒ»ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
    function setupControls() {
      let isMouseDown = false;
      let mouseX = 0, mouseY = 0;

      const canvas = renderer.domElement;

      canvas.addEventListener('mousedown', function(e) {
        isMouseDown = true;
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      canvas.addEventListener('mouseup', function() {
        isMouseDown = false;
      });

      canvas.addEventListener('mousemove', function(e) {
        if (!isMouseDown || !currentModel) return;
        
        const deltaX = e.clientX - mouseX;
        const deltaY = e.clientY - mouseY;
        
        currentModel.rotation.y += deltaX * 0.01;
        currentModel.rotation.x += deltaY * 0.01;
        
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      canvas.addEventListener('wheel', function(e) {
        e.preventDefault();
        if (currentModel) {
          const scale = e.deltaY > 0 ? 0.9 : 1.1;
          currentModel.scale.multiplyScalar(scale);
        } else {
          camera.position.z += e.deltaY * 0.01;
          camera.position.z = Math.max(1, Math.min(50, camera.position.z));
        }
      });
    }

    // è¤‡æ•°ã®CORSãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒ“ã‚¹
    const CORS_PROXIES = [
      'https://api.allorigins.win/raw?url=',
      'https://corsproxy.io/?',
      'https://cors-anywhere.herokuapp.com/'
    ];

    // ã‚ˆã‚Šå …ç‰¢ãªãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ï¼ˆCORSå›é¿å¯¾å¿œï¼‰
    async function loadModel(url, useProxy = false) {
      if (isLoading || !url.trim()) {
        if (!url.trim()) updateStatus('URLãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“', 'warning');
        return;
      }
      
      setLoading(true);
      
      try {
        // ãƒ¢ãƒ‡ãƒ«ã‚¯ãƒªã‚¢
        if (currentModel) {
          scene.remove(currentModel);
          currentModel = null;
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼è‡ªå‹•åˆ¤åˆ¥
        const format = detectFileFormat(url);
        updateStatus(`${format.toUpperCase()}ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦èª­ã¿è¾¼ã¿ä¸­...`, 'warning');

        // URLä¿®æ­£
        let targetUrl = fixDropboxURL(url);
        console.log('Target URL:', targetUrl);

        let data;
        let success = false;

        if (useProxy) {
          // ãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§èª­ã¿è¾¼ã¿
          updateStatus('CORSåˆ¶é™å›é¿ã®ãŸã‚ã€ãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½¿ç”¨ä¸­...', 'warning');
          
          for (let i = 0; i < CORS_PROXIES.length && !success; i++) {
            const proxyUrl = CORS_PROXIES[i] + encodeURIComponent(targetUrl);
            console.log(`Trying proxy ${i + 1}/${CORS_PROXIES.length}:`, proxyUrl);
            
            try {
              const response = await fetch(proxyUrl, {
                method: 'GET',
                headers: {
                  'Accept': 'text/plain, application/octet-stream, */*'
                }
              });
              
              if (response.ok) {
                data = await response.text();
                console.log(`Proxy ${i + 1} successful, data length:`, data.length);
                success = true;
                updateStatus(`ãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§èª­ã¿è¾¼ã¿æˆåŠŸ (${format.toUpperCase()})`, 'success');
                break;
              } else {
                console.log(`Proxy ${i + 1} failed:`, response.status, response.statusText);
              }
            } catch (proxyError) {
              console.log(`Proxy ${i + 1} error:`, proxyError.message);
            }
          }
          
          if (!success) {
            throw new Error('å…¨ã¦ã®ãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒ“ã‚¹ã§èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚');
          }
          
        } else {
          // ç›´æ¥èª­ã¿è¾¼ã¿
          console.log('Trying direct access...');
          
          // è¤‡æ•°ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’è©¦è¡Œ
          const attempts = [
            { url: targetUrl, mode: 'cors' },
            { url: targetUrl, mode: 'no-cors' }, // no-corsãƒ¢ãƒ¼ãƒ‰ã‚‚è©¦è¡Œ
            { url: targetUrl.replace('&raw=1', '&dl=1'), mode: 'cors' }, // ä»£æ›¿ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
          ];

          for (const attempt of attempts) {
            try {
              console.log(`Trying direct access: ${attempt.url} (mode: ${attempt.mode})`);
              
              const response = await fetch(attempt.url, {
                method: 'GET',
                mode: attempt.mode,
                cache: 'no-cache',
                headers: {
                  'Accept': 'text/plain, application/octet-stream, */*',
                  'User-Agent': 'Mozilla/5.0 (compatible; 3DViewer/1.0)'
                }
              });
              
              if (response.ok) {
                data = await response.text();
                if (data && data.length > 0) {
                  console.log('Direct access successful, data length:', data.length);
                  success = true;
                  break;
                }
              }
            } catch (directError) {
              console.log('Direct access attempt failed:', directError.message);
            }
          }
          
          if (!success) {
            throw new Error('CORSåˆ¶é™ã«ã‚ˆã‚Šãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“ã€‚ã€Œãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã€ãƒœã‚¿ãƒ³ã‚’è©¦ã™ã‹ã€ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚');
          }
        }

        if (!data || data.length === 0) {
          throw new Error('ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ãƒ¼ã‚¿ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ');
        }

        console.log(`Data loaded successfully, length: ${data.length}, format: ${format}`);

        // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆåˆ¥ãƒ‘ãƒ¼ã‚¹
        if (format === 'obj') {
          currentModel = parseOBJ(data);
        } else if (format === 'stl') {
          currentModel = parseSTL(data);
        } else {
          throw new Error('GLBãƒ•ã‚¡ã‚¤ãƒ«ã¯ç¾åœ¨éå¯¾å¿œã§ã™ã€‚OBJã¾ãŸã¯STLãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚');
        }

        if (currentModel) {
          scene.add(currentModel);
          
          // ãƒ¢ãƒ‡ãƒ«ã‚’ä¸­å¤®ã«é…ç½®
          const box = new THREE.Box3().setFromObject(currentModel);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());
          
          currentModel.position.sub(center);
          
          // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’èª¿æ•´ï¼ˆVRå¯¾å¿œï¼‰
          const maxDim = Math.max(size.x, size.y, size.z);
          // VRãƒ¢ãƒ¼ãƒ‰ç”¨ã«è·é›¢ã‚’å¤§ããå–ã‚‹
          const vrDistance = maxDim * 4; // é€šå¸¸ã®2å€ã®è·é›¢
          camera.position.set(0, 1.6, vrDistance); // VRç”¨ã®é«˜ã•ã¨è·é›¢
          
          updateStatus(`ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†ï¼ (${format.toUpperCase()}, ã‚µã‚¤ã‚º: ${maxDim.toFixed(2)}, VRè·é›¢: ${vrDistance.toFixed(2)})`, 'success');
        }

      } catch (error) {
        console.error('Load error:', error);
        let errorMessage = error.message || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
        
        // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è©³ç´°åŒ–
        if (errorMessage.includes('Failed to fetch')) {
          errorMessage = 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ (CORSåˆ¶é™ã®å¯èƒ½æ€§)ã€‚ã€Œãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã€ãƒœã‚¿ãƒ³ã‚’è©¦ã—ã¦ãã ã•ã„ã€‚';
        } else if (errorMessage.includes('NetworkError')) {
          errorMessage = 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚¨ãƒ©ãƒ¼ã€‚ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
        } else if (errorMessage.includes('404')) {
          errorMessage = 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚URLãŒæ­£ã—ã„ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
        }
        
        updateStatus(`èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${errorMessage}`, 'error');
      } finally {
        setLoading(false);
      }
    }

    // ã‚·ãƒ³ãƒ—ãƒ«ãªOBJãƒ‘ãƒ¼ã‚µãƒ¼ï¼ˆæ”¹è‰¯ç‰ˆï¼‰
    function parseOBJ(data) {
      const vertices = [];
      const normals = [];
      const faces = [];
      const lines = data.split('\n');
      
      console.log(`Parsing OBJ file with ${lines.length} lines`);
      
      for (const line of lines) {
        const parts = line.trim().split(/\s+/);
        
        if (parts[0] === 'v' && parts.length >= 4) {
          vertices.push(
            parseFloat(parts[1]),
            parseFloat(parts[2]),
            parseFloat(parts[3])
          );
        } else if (parts[0] === 'vn' && parts.length >= 4) {
          normals.push(
            parseFloat(parts[1]),
            parseFloat(parts[2]),
            parseFloat(parts[3])
          );
        } else if (parts[0] === 'f' && parts.length >= 4) {
          // ä¸‰è§’å½¢é¢ã®å‡¦ç†
          for (let i = 1; i <= 3; i++) {
            const vertexData = parts[i].split('/');
            const vertexIndex = parseInt(vertexData[0]) - 1;
            faces.push(vertexIndex);
          }
          
          // å››è§’å½¢ã®å ´åˆã¯è¿½åŠ ã®ä¸‰è§’å½¢ã‚’ä½œæˆ
          if (parts.length >= 5) {
            const indices = [1, 3, 4];
            for (const i of indices) {
              const vertexData = parts[i].split('/');
              const vertexIndex = parseInt(vertexData[0]) - 1;
              faces.push(vertexIndex);
            }
          }
        }
      }

      console.log(`Parsed: ${vertices.length/3} vertices, ${faces.length/3} triangles`);

      const geometry = new THREE.BufferGeometry();
      const positionArray = new Float32Array(faces.length * 3);
      
      for (let i = 0; i < faces.length; i++) {
        const vertexIndex = faces[i];
        positionArray[i * 3] = vertices[vertexIndex * 3] || 0;
        positionArray[i * 3 + 1] = vertices[vertexIndex * 3 + 1] || 0;
        positionArray[i * 3 + 2] = vertices[vertexIndex * 3 + 2] || 0;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
      geometry.computeVertexNormals();
      geometry.center();

      const material = new THREE.MeshLambertMaterial({ 
        color: 0x888888,
        side: THREE.DoubleSide
      });
      
      return new THREE.Mesh(geometry, material);
    }

    // STLãƒ‘ãƒ¼ã‚µãƒ¼ï¼ˆASCIIå¯¾å¿œï¼‰
    function parseSTL(data) {
      const vertices = [];
      const lines = data.split('\n');
      
      console.log(`Parsing STL file with ${lines.length} lines`);
      
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith('vertex')) {
          const parts = trimmed.split(/\s+/);
          if (parts.length >= 4) {
            vertices.push(
              parseFloat(parts[1]),
              parseFloat(parts[2]),
              parseFloat(parts[3])
            );
          }
        }
      }

      console.log(`Parsed STL: ${vertices.length/3} vertices`);

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
      geometry.computeVertexNormals();
      geometry.center();

      const material = new THREE.MeshLambertMaterial({ 
        color: 0x888888,
        side: THREE.DoubleSide
      });
      
      return new THREE.Mesh(geometry, material);
    }

    // ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ï¼ˆæ”¹è‰¯ç‰ˆï¼‰
    function loadFromFile(file) {
      if (isLoading || !file) return;
      
      setLoading(true);
      const format = detectFileFormat('', file.name);
      updateStatus(`ãƒ­ãƒ¼ã‚«ãƒ«${format.toUpperCase()}ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...`, 'warning');
      
      const reader = new FileReader();
      
      reader.onload = function(e) {
        try {
          const data = e.target.result;

          // ãƒ¢ãƒ‡ãƒ«ã‚¯ãƒªã‚¢
          if (currentModel) {
            scene.remove(currentModel);
            currentModel = null;
          }

          // ãƒ‘ãƒ¼ã‚¹
          if (format === 'obj') {
            currentModel = parseOBJ(data);
          } else if (format === 'stl') {
            currentModel = parseSTL(data);
          } else {
            throw new Error('å¯¾å¿œã—ã¦ã„ãªã„ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™');
          }

          if (currentModel) {
            scene.add(currentModel);
            
            // ä½ç½®ã¨ã‚«ãƒ¡ãƒ©èª¿æ•´
            const box = new THREE.Box3().setFromObject(currentModel);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            // VRç”¨ã«ã‚ˆã‚Šé ã„è·é›¢
            const vrDistance = maxDim * 5;
            camera.position.set(0, 1.6, vrDistance);
            
            updateStatus(`ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å®Œäº†ï¼ (${format.toUpperCase()}, ${file.name}, VRè·é›¢: ${vrDistance.toFixed(2)})`, 'success');
          }

        } catch (error) {
          console.error('File processing error:', error);
          updateStatus('ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
        } finally {
          setLoading(false);
        }
      };
      
      reader.onerror = function() {
        updateStatus('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼', 'error');
        setLoading(false);
      };
      
      reader.readAsText(file);
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
    function setupEventListeners() {
      console.log('Setting up event listeners...');
      
      loadBtn.onclick = function() {
        console.log('Load button clicked, URL:', urlInput.value);
        const url = urlInput.value.trim();
        if (url) {
          // dropbox URLã¯å¿…ãšãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§èª­ã¿è¾¼ã¿
          const useProxy = url.includes('dropbox.com');
          loadModel(url, useProxy);
        } else {
          updateStatus('URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'warning');
        }
      };

      pasteBtn.onclick = async function() {
        console.log('Paste button clicked');
        try {
          const text = await navigator.clipboard.readText();
          urlInput.value = text;
          updateStatus('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‹ã‚‰URLã‚’è²¼ã‚Šä»˜ã‘ã¾ã—ãŸ', 'success');
        } catch (error) {
          console.error('Paste error:', error);
          updateStatus('è²¼ã‚Šä»˜ã‘ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
        }
      };

      fileBtn.onclick = function() {
        console.log('File button clicked');
        fileInput.click();
      };

      resetBtn.onclick = function() {
        console.log('Reset button clicked');
        if (currentModel) {
          scene.remove(currentModel);
          currentModel = null;
          updateStatus('ãƒ¢ãƒ‡ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ', 'success');
        }
        camera.position.set(0, 1.6, 8); // VRç”¨ã«ã‚ˆã‚Šé ã„ä½ç½®
        urlInput.value = '';
      };

      fileInput.onchange = function(e) {
        const file = e.target.files[0];
        if (file) {
          console.log('File selected:', file.name);
          loadFromFile(file);
        }
      };

      // ãƒ¢ãƒ‡ãƒ«æ“ä½œãƒœã‚¿ãƒ³
      rotateL.onclick = () => { if (currentModel) currentModel.rotation.y -= Math.PI / 8; };
      rotateR.onclick = () => { if (currentModel) currentModel.rotation.y += Math.PI / 8; };
      rotateUp.onclick = () => { if (currentModel) currentModel.rotation.x -= Math.PI / 8; };
      rotateDown.onclick = () => { if (currentModel) currentModel.rotation.x += Math.PI / 8; };
      scaleUp.onclick = () => { if (currentModel) currentModel.scale.multiplyScalar(1.2); };
      scaleDown.onclick = () => { if (currentModel) currentModel.scale.multiplyScalar(0.8); };

      // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
      document.addEventListener('dragover', function(e) {
        e.preventDefault();
        dropZone.style.display = 'grid';
      });

      document.addEventListener('dragleave', function(e) {
        if (!e.relatedTarget) dropZone.style.display = 'none';
      });

      document.addEventListener('drop', function(e) {
        e.preventDefault();
        dropZone.style.display = 'none';
        const file = e.dataTransfer.files[0];
        if (file) loadFromFile(file);
      });

      // ãƒªã‚µã‚¤ã‚º
      window.addEventListener('resize', function() {
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });
    }

    // åˆæœŸåŒ–
    console.log('Initializing PICO4 WebXR Viewer...');
    updateStatus('ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åˆæœŸåŒ–ä¸­...', 'warning');
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function() {
        setupEventListeners();
        initThreeJS();
      });
    } else {
      setupEventListeners();
      initThreeJS();
    }

    // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
    window.addEventListener('error', function(e) {
      console.error('Global error:', e);
      updateStatus('ã‚¨ãƒ©ãƒ¼: ' + e.message, 'error');
    });

    window.addEventListener('unhandledrejection', function(e) {
      console.error('Unhandled promise rejection:', e);
      updateStatus('éåŒæœŸã‚¨ãƒ©ãƒ¼: ' + e.reason, 'error');
    });

  </script>
</body>
</html>
