<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>PICO4 WebXR 3D Viewer (Simple)</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0d10;color:#e8eef8;font-family:Arial, sans-serif}
    #ui{position:fixed;left:10px;right:10px;top:10px;background:rgba(0,0,0,0.8);padding:15px;border-radius:8px;z-index:100}
    #controls{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:10px}
    #url{flex:1;min-width:200px;padding:8px;border:1px solid #444;background:#222;color:#fff;border-radius:4px}
    button{padding:8px 12px;border:1px solid #444;background:#333;color:#fff;border-radius:4px;cursor:pointer}
    button:hover{background:#555}
    button:disabled{background:#111;color:#666;cursor:not-allowed}
    #status{background:#111;padding:8px;border-radius:4px;font-size:12px;margin-top:10px;border-left:4px solid #666}
    .error{border-left-color:#ff4444}
    .success{border-left-color:#44ff44}
    .warning{border-left-color:#ffff44}
    #fileInput{display:none}
    #dropZone{position:fixed;inset:0;border:3px dashed #44f;display:none;place-content:center;background:rgba(0,100,255,0.1);z-index:50;font-size:24px;color:#44f}
  </style>
</head>
<body>
  <div id="ui">
    <div id="controls">
      <select id="format">
        <option value="obj">OBJ</option>
        <option value="glb">GLB</option>
        <option value="stl">STL</option>
      </select>
      <input id="url" placeholder="3D Model URL" value="">
      <button id="loadBtn">読み込む</button>
      <button id="proxyBtn">プロキシ経由</button>
      <button id="fileBtn">ファイル選択</button>
      <button id="resetBtn">リセット</button>
    </div>
    <div id="controls">
      <button id="rotateL">⟲ 左回転</button>
      <button id="rotateR">⟳ 右回転</button>
      <button id="scaleUp">拡大 +</button>
      <button id="scaleDown">縮小 -</button>
    </div>
    <div id="status">準備完了 - URLを入力して読み込んでください</div>
  </div>

  <input type="file" id="fileInput" accept=".obj,.glb,.gltf,.stl">
  <div id="dropZone">ファイルをドロップしてください</div>

  <script>
    console.log('Script starting...');
    
    // グローバル変数
    let scene, camera, renderer, controls, currentModel;
    let isLoading = false;
    
    // UI要素を取得
    const statusEl = document.getElementById('status');
    const urlInput = document.getElementById('url');
    const formatSelect = document.getElementById('format');
    const loadBtn = document.getElementById('loadBtn');
    const proxyBtn = document.getElementById('proxyBtn');
    const fileBtn = document.getElementById('fileBtn');
    const resetBtn = document.getElementById('resetBtn');
    const fileInput = document.getElementById('fileInput');
    const dropZone = document.getElementById('dropZone');
    const rotateL = document.getElementById('rotateL');
    const rotateR = document.getElementById('rotateR');
    const scaleUp = document.getElementById('scaleUp');
    const scaleDown = document.getElementById('scaleDown');

    // ステータス更新関数
    function updateStatus(message, type) {
      console.log('Status:', message, type);
      statusEl.textContent = message;
      statusEl.className = type || '';
    }

    // ローディング状態管理
    function setLoading(loading) {
      isLoading = loading;
      loadBtn.disabled = loading;
      proxyBtn.disabled = loading;
      if (loading) {
        updateStatus('読み込み中...', 'warning');
      }
    }

    // URL正規化
    function fixDropboxURL(url) {
      if (!url || !url.includes('dropbox.com')) return url;
      
      console.log('Original URL:', url);
      
      // 新しいDropbox形式
      if (url.includes('/scl/fi/')) {
        if (url.includes('&dl=0')) {
          url = url.replace('&dl=0', '&dl=1');
        } else if (url.includes('?dl=0')) {
          url = url.replace('?dl=0', '?dl=1');
        } else if (!url.includes('dl=1') && !url.includes('raw=1')) {
          url = url + (url.includes('?') ? '&raw=1' : '?raw=1');
        }
      } 
      // 古いDropbox形式
      else {
        const baseUrl = url.split('?')[0];
        url = baseUrl + '?raw=1';
      }
      
      console.log('Fixed URL:', url);
      return url;
    }

    // Three.jsの初期化（シンプル版）
    function initThreeJS() {
      try {
        console.log('Initializing Three.js...');
        
        // Three.jsのライブラリを動的に読み込み
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
        script.onload = function() {
          console.log('Three.js loaded');
          setupScene();
        };
        script.onerror = function() {
          updateStatus('Three.js読み込みエラー', 'error');
        };
        document.head.appendChild(script);
        
      } catch (error) {
        console.error('Init error:', error);
        updateStatus('初期化エラー: ' + error.message, 'error');
      }
    }

    // シーン設定
    function setupScene() {
      try {
        console.log('Setting up scene...');
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0b0d10);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // WebXRボタン追加
        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-vr').then(function(supported) {
            if (supported) {
              const vrButton = document.createElement('button');
              vrButton.style.position = 'fixed';
              vrButton.style.bottom = '20px';
              vrButton.style.right = '20px';
              vrButton.style.padding = '12px 20px';
              vrButton.style.background = '#1976d2';
              vrButton.style.color = 'white';
              vrButton.style.border = 'none';
              vrButton.style.borderRadius = '6px';
              vrButton.textContent = 'Enter VR';
              vrButton.onclick = function() {
                renderer.xr.getSession() ? renderer.xr.getSession().end() : 
                navigator.xr.requestSession('immersive-vr').then(function(session) {
                  renderer.xr.setSession(session);
                });
              };
              document.body.appendChild(vrButton);
            }
          }).catch(function(error) {
            console.log('VR not supported:', error);
          });
        }

        // ライト
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(10, 10, 5);
        scene.add(directionalLight);

        // グリッド
        const gridHelper = new THREE.GridHelper(10, 10);
        scene.add(gridHelper);

        // コントロール（マウス操作）
        setupControls();

        // アニメーションループ開始
        animate();

        updateStatus('3Dエンジン初期化完了', 'success');
        
      } catch (error) {
        console.error('Scene setup error:', error);
        updateStatus('シーン設定エラー: ' + error.message, 'error');
      }
    }

    // シンプルなマウスコントロール
    function setupControls() {
      let isMouseDown = false;
      let mouseX = 0, mouseY = 0;

      renderer.domElement.addEventListener('mousedown', function(e) {
        isMouseDown = true;
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      renderer.domElement.addEventListener('mouseup', function() {
        isMouseDown = false;
      });

      renderer.domElement.addEventListener('mousemove', function(e) {
        if (!isMouseDown || !currentModel) return;
        
        const deltaX = e.clientX - mouseX;
        const deltaY = e.clientY - mouseY;
        
        currentModel.rotation.y += deltaX * 0.01;
        currentModel.rotation.x += deltaY * 0.01;
        
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      // ホイールでズーム
      renderer.domElement.addEventListener('wheel', function(e) {
        e.preventDefault();
        camera.position.z += e.deltaY * 0.01;
        camera.position.z = Math.max(1, Math.min(20, camera.position.z));
      });
    }

    // アニメーションループ
    function animate() {
      renderer.setAnimationLoop(function() {
        handleVRControls();
        renderer.render(scene, camera);
      });
    }

    // VRコントロール
    function handleVRControls() {
      if (!renderer.xr.isPresenting || !currentModel) return;
      
      const session = renderer.xr.getSession();
      if (!session) return;

      for (const source of session.inputSources) {
        if (source.gamepad && source.gamepad.axes) {
          const axes = source.gamepad.axes;
          if (axes.length >= 4) {
            // スティック操作
            if (Math.abs(axes[2]) > 0.1) {
              currentModel.rotation.y += axes[2] * 0.05;
            }
            if (Math.abs(axes[3]) > 0.1) {
              const scale = 1 + (-axes[3] * 0.02);
              currentModel.scale.multiplyScalar(scale);
            }
          }
        }
      }
    }

    // モデル読み込み（fetch版）
    async function loadModel(url, format, useProxy) {
      if (isLoading) return;
      
      setLoading(true);
      
      try {
        // 現在のモデルをクリア
        if (currentModel) {
          scene.remove(currentModel);
          currentModel = null;
        }

        // URL修正
        let fixedUrl = fixDropboxURL(url);
        
        // プロキシ使用
        if (useProxy) {
          fixedUrl = 'https://cors-anywhere.herokuapp.com/' + fixedUrl;
          updateStatus('プロキシ経由で読み込み中...', 'warning');
        }

        console.log('Loading from:', fixedUrl);

        // fetchでデータ取得
        const response = await fetch(fixedUrl);
        
        if (!response.ok) {
          throw new Error('HTTP ' + response.status + ': ' + response.statusText);
        }

        const data = await response.text();
        console.log('Data loaded, length:', data.length);

        // フォーマット別の処理
        if (format === 'obj') {
          currentModel = parseOBJ(data);
        } else if (format === 'stl') {
          // STLは簡単なパーサーを実装
          currentModel = parseSTL(data);
        } else {
          throw new Error('GLBはブラウザ制限のため未対応です。OBJまたはSTLを使用してください。');
        }

        if (currentModel) {
          scene.add(currentModel);
          
          // モデルを画面中央に配置
          const box = new THREE.Box3().setFromObject(currentModel);
          const center = box.getCenter(new THREE.Vector3());
          currentModel.position.sub(center);
          
          // カメラ位置調整
          const size = box.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z);
          camera.position.set(0, maxDim * 0.5, maxDim * 2);
          
          updateStatus('モデル読み込み完了 (頂点数: ' + currentModel.geometry?.attributes?.position?.count + ')', 'success');
        }

      } catch (error) {
        console.error('Load error:', error);
        let message = 'エラー: ';
        if (error.message.includes('CORS')) {
          message += 'CORS制限エラー。プロキシ経由を試してください。';
        } else if (error.message.includes('404')) {
          message += 'ファイルが見つかりません。URLを確認してください。';
        } else if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch')) {
          message += 'ネットワークエラー。プロキシ経由を試してください。';
        } else {
          message += error.message;
        }
        updateStatus(message, 'error');
      } finally {
        setLoading(false);
      }
    }

    // シンプルなOBJパーサー
    function parseOBJ(data) {
      const vertices = [];
      const faces = [];
      const lines = data.split('\n');
      
      for (const line of lines) {
        const parts = line.trim().split(/\s+/);
        if (parts[0] === 'v') {
          vertices.push(
            parseFloat(parts[1]),
            parseFloat(parts[2]),
            parseFloat(parts[3])
          );
        } else if (parts[0] === 'f') {
          // 三角形のみ対応
          if (parts.length >= 4) {
            for (let i = 1; i <= 3; i++) {
              const vertexIndex = parseInt(parts[i].split('/')[0]) - 1;
              faces.push(vertexIndex);
            }
          }
        }
      }

      const geometry = new THREE.BufferGeometry();
      const positionArray = new Float32Array(faces.length * 3);
      
      for (let i = 0; i < faces.length; i++) {
        const vertexIndex = faces[i];
        positionArray[i * 3] = vertices[vertexIndex * 3];
        positionArray[i * 3 + 1] = vertices[vertexIndex * 3 + 1];
        positionArray[i * 3 + 2] = vertices[vertexIndex * 3 + 2];
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
      geometry.computeVertexNormals();

      const material = new THREE.MeshLambertMaterial({ color: 0x888888 });
      return new THREE.Mesh(geometry, material);
    }

    // シンプルなSTLパーサー（ASCII版のみ）
    function parseSTL(data) {
      const vertices = [];
      const lines = data.split('\n');
      
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith('vertex')) {
          const parts = trimmed.split(/\s+/);
          vertices.push(
            parseFloat(parts[1]),
            parseFloat(parts[2]),
            parseFloat(parts[3])
          );
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
      geometry.computeVertexNormals();

      const material = new THREE.MeshLambertMaterial({ color: 0x888888 });
      return new THREE.Mesh(geometry, material);
    }

    // ファイル読み込み
    function loadFromFile(file) {
      if (isLoading || !file) return;
      
      setLoading(true);
      updateStatus('ファイル読み込み中...', 'warning');
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = e.target.result;
          const fileName = file.name.toLowerCase();
          let format;
          
          if (fileName.endsWith('.obj')) format = 'obj';
          else if (fileName.endsWith('.stl')) format = 'stl';
          else throw new Error('対応していないファイル形式です');

          // 現在のモデルクリア
          if (currentModel) {
            scene.remove(currentModel);
            currentModel = null;
          }

          // パース
          if (format === 'obj') {
            currentModel = parseOBJ(data);
          } else if (format === 'stl') {
            currentModel = parseSTL(data);
          }

          if (currentModel) {
            scene.add(currentModel);
            
            // 位置調整
            const box = new THREE.Box3().setFromObject(currentModel);
            const center = box.getCenter(new THREE.Vector3());
            currentModel.position.sub(center);
            
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            camera.position.set(0, maxDim * 0.5, maxDim * 2);
            
            updateStatus('ファイル読み込み完了', 'success');
          }

        } catch (error) {
          updateStatus('ファイル処理エラー: ' + error.message, 'error');
        } finally {
          setLoading(false);
        }
      };
      
      reader.onerror = function() {
        updateStatus('ファイル読み込みエラー', 'error');
        setLoading(false);
      };
      
      reader.readAsText(file);
    }

    // イベントリスナー設定
    function setupEventListeners() {
      console.log('Setting up event listeners...');
      
      // ボタンイベント
      loadBtn.onclick = function() {
        console.log('Load button clicked');
        const url = urlInput.value.trim();
        if (url) {
          loadModel(url, formatSelect.value, false);
        } else {
          updateStatus('URLを入力してください', 'warning');
        }
      };

      proxyBtn.onclick = function() {
        console.log('Proxy button clicked');
        const url = urlInput.value.trim();
        if (url) {
          loadModel(url, formatSelect.value, true);
        } else {
          updateStatus('URLを入力してください', 'warning');
        }
      };

      fileBtn.onclick = function() {
        console.log('File button clicked');
        fileInput.click();
      };

      resetBtn.onclick = function() {
        console.log('Reset button clicked');
        if (currentModel) {
          scene.remove(currentModel);
          currentModel = null;
          updateStatus('リセットしました', 'success');
        }
        camera.position.set(0, 2, 5);
        urlInput.value = '';
      };

      // ファイル選択
      fileInput.onchange = function(e) {
        const file = e.target.files[0];
        if (file) loadFromFile(file);
      };

      // モデル操作
      rotateL.onclick = function() {
        if (currentModel) currentModel.rotation.y -= Math.PI / 8;
      };

      rotateR.onclick = function() {
        if (currentModel) currentModel.rotation.y += Math.PI / 8;
      };

      scaleUp.onclick = function() {
        if (currentModel) currentModel.scale.multiplyScalar(1.2);
      };

      scaleDown.onclick = function() {
        if (currentModel) currentModel.scale.multiplyScalar(0.8);
      };

      // ドラッグ&ドロップ
      document.addEventListener('dragover', function(e) {
        e.preventDefault();
        dropZone.style.display = 'grid';
      });

      document.addEventListener('dragleave', function(e) {
        if (!e.relatedTarget) {
          dropZone.style.display = 'none';
        }
      });

      document.addEventListener('drop', function(e) {
        e.preventDefault();
        dropZone.style.display = 'none';
        const file = e.dataTransfer.files[0];
        if (file) loadFromFile(file);
      });

      // リサイズ
      window.addEventListener('resize', function() {
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });
    }

    // 初期化開始
    console.log('Starting initialization...');
    updateStatus('初期化中...', 'warning');
    
    // ページ読み込み完了後に初期化
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function() {
        setupEventListeners();
        initThreeJS();
      });
    } else {
      setupEventListeners();
      initThreeJS();
    }

    // エラーハンドリング
    window.addEventListener('error', function(e) {
      console.error('Global error:', e);
      updateStatus('エラーが発生しました: ' + e.message, 'error');
    });

  </script>
</body>
</html>
